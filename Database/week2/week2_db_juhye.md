## 4.7 내포된 SQL

- 불일치 문제와 커서
  - 호스트 언어는 단일 변수/레코드 위주의 처리(튜플 위주의 방식)를 지원하는 반면에 SQL은 데이터 레코드들의 처리(집합 위주의 방식)를 지원하기 때문에 불일치 문제가 발생함
  - 불일치 문제를 해결하기 위해서 커서(cursor)가 사용됨
  - 커서는 한 번에 한 튜플씩 가져오는 수단
  - DECLARE CURSOR문을 사용하여 커서를 정의함
  - OPEN cursor문은 질의를 수행하고, 질의 수행 결과의 첫 번째 튜플 이전을 커서가가리키도록 함 이 것이 현재 튜플
  - 그 다음에 FETCH문은 커서를 다음 튜플로 이동하고, 그 튜플의 애트리뷰트 값들을 FETCH문에 명시된 호스트 변수들에 복사함
  - CLOSE cursor 커서 닫음
- SQL 통신 영역(SQLCA)
  - C 프로그램에 내포된 SQL문에 발생하는 에러들을 사용자에게 알려줌
  - 사용자는 SQLCA 데이터 구조의 에러 필드와 상태 표시자를 검사하여 내포된 SQL문이 성공적으로 수행되었는가 또는 비정상적으로 수행되었는가를 파악할 수 있음
  - SQLCA 데이터 구조 중에서 가장 중요하고 널리 사용되는 필드는 SQLCODE 변수



# 5장. 데이터베이스 설계와 ER 모델

- 데이터베이스 셜계
  - 개념적 데이터베이스 설계는 실제로 데이터베이스를 어떻게 구현할 것인가와는 독립적으로 정보 사용의 모델을 개발하는 과정
  - 물리적 데이터베이스 셜계에서는 물리적인 저장 장치와 접근 방식을 다룸
  - 개념적 데이터베이스 셜계 과정에서 조직체(실세계)의 엔티티 ,관계, 프로세스, 무결성 제약조건 등을 나타내는 추상화 모델을 구축
- 개념적 수준의 모델
  - 특정 데이터 모델과 독립적으로 응용 세계를 모델링할 수 있도록 함
  - 데이터 베이스 구조나 스키마를 하향식으로 개발할 수 있기 위한 틀을 제공
  - 인기 있는 개념적 수준의 모델은 엔티티-관계(ER) 모델



## 5.1 데이터베이스 설계의 개요

- 데이터베이스 설계의 개요
  - 한 조직체의 운영과 목적을 지원하기 위해 데이터베이스를 생성하는 과정
  - 목적은 모든 주요 응용과 사용자들이 요구하는 데이터, 데이터 간의 관계를 표현하는 것
  - 데이터베이스 개발은 일반적인 프로젝트 라이프 사이클 과정을 따름
  - 훌륭한 데이터베이스 셜계는 시간의 흐름에 따른 데이터의 모든 측면을 나타내고, 데이터 항목을 중복을 최소화, 데이터베이스에 대한 효율적 접근 제공, 데이터베이스의 무결성 제공, 이해하기 쉬워야함
- 요구사항 수집과 분석
  - 흔히 기존의 문서를 조사, 인터뷰, 설문 조사 등
  - 요구사항에 관한 지식을 기반으로 관련 있는 엔티티들과 이들의 애트리뷰트들이 무엇인가, 엔티티들 간의 관계가 무엇인가 등을 파악
  - 또한 데이터 처리에 관한 요구사항에 대해 전형적인 연산들은 무엇인가, 연산들의 의미, 접근하는 데이터의 양 등을 분석

- DBMS 선정
  - 여러 가지 요인들을 검토한 후 DBMS를 선정함
  - 기술적인 요인을 DBMS가 제공하는 데이터 모델, 저장 구조, 인터페이스, 질의어, 도구, 제공되는 서비스 등
- 물리적 설계
  - 처리 요구사항들을 만족시키기 위해 저장 구조와 접근 경로 등을 결정함

- 트랜잭션 설계
  - 요구 사항 수집과 분석 후에 데이터베이스 설계 과정과 별도로 트랜잭션 설계를 진행할 수 있음



## 5.2 ER 모델

- ER 모델

  - 데이터베이스 설계를 용이하게 하기 위해서 P.P Chen이 1976년에 제안하였음
  - 현재는 EER 모델이 데이터베이스 설계 과정에 널리 사용되고 있음
  - 개념적인 설계를 위한 인기 있는 모델로서, 높은 수준으로 추상화하며, 이해하기 쉬우며, 구문들의 표현력이 뛰어나고 사람들의 응용에 대해 생각하는 방식과 가깝고, 많은 CASE 도구들에서 지원됨

  - 현재는 데이터베이스 설계를 위한 다소 구형 그래픽 표기법

- 엔티티 타입
  - 엔티티들은 엔티티 타입(또는 엔티티 집합)들로 분류됨
  - 엔티티 타입은 동일한 애트리뷰트들을 가진 엔티티들의 틀
  - 엔티티 집합은 동일한 애트리뷰트들을 가진 엔티티들의 모임
  - 하나의 엔티티는 한 개 이상의 엔티티 집합에 속할 수 있음
  - 엔티티 타입은 관계 모델의 릴레이션의 내포에 해당하고, 엔티티 집합은 관계 모델의 릴레이션의 외연에 해당
  - 엔티티 집합과 엔티티 타입을 엄격하게 구분할 필요 없음
  - ER 다이어그램에서 엔티티 타입은 직사각형으로 나타냄

- 강한 엔티티 타입
  - 강한 엔티티 타입(정규 엔티티 타입)은 독자적으로 존재하며 엔티티 타입 내에서 자신의 키 애트리뷰트를 사용하여 고유하게 엔티티들을 식별할 수 있는 엔티티 타입
- 약한 엔티티 타입
  - 약한 엔티티 타입은 키를 형성하기에 충분한 애트리뷰트들을 갖지 못한 엔티티 타입
  - 이 엔티티 타입이 존재하려면 소유 엔티티 타입이 있어야 함
  - 소유 엔티티 타입의 키 애트리뷰트를 결합해야만 고유하게 약한 엔티티 타입의 엔티티들을 식별할 수 있음
- 애트리뷰트
  - 하나의 엔티티는 연관된 애트리뷰트들의 집합으로 설명됨
  - 한 애트리뷰트의 도메인은 그 애트리뷰트가 가질 수 있는 모든 가능한 값들의 집합을 의미
  - 여러 애트리뷰트가 동일한 도메인 공유 가능
  - 키 애트리뷰트는 한 애트리뷰트 또는 애트리뷰트들의 모임으로서 한 엔티티 타입 내에서 각 엔티티를 고유하게 식별
  - ER 다이어그램에서 기본 키에 속하는 애트리뷰트는 밑줄을 그어 표시

- 단순 애트리뷰트
  - 더 이상 애트리뷰트로 나눌 수 없는 애트리뷰트
  - ER 다이어그램에서 실선 타원으로 표현
  - ER 다이어그램에서 대부분 애트리뷰트는 단순 애트리뷰트
- 복합 애트리뷰트
  - 두 개 이상의 애트리뷰트로 이루어진 애트리뷰트
  - 동일한 엔티티타입이나 관계 타입에 속하는 애트리뷰트들 중에서 밀접하게 연관된 것을 모아놓은 것
- 단일값 애트리뷰트
  - 각 엔터티마다 정확하게 하나의 값을 갖는 애트리뷰트
  - ER 다이어그램에서 단순 애트리뷰트와 동일하게 표현
- 다치 애트리뷰트
  - 각 엔터티마다 여러 개의 값을 가질 수 있는 애트리뷰트
  - ER 다이어그램에서 이중선 타원으로 표현
- 저장된 애트리뷰트
  - 다른 애트리뷰트와 독립적으로 존재하는 애트리뷰트

- 유도된 애트리뷰트
  - 다른 애트리뷰트의 값으로 얻어진 애트리뷰트
  - 관계 데이터베이스에서 릴레이션의 애트리뷰트로 포함시키지 않는 것이 좋음
  - 점선 타원으로 표현
- 약한 엔티티 타입
  - 키를 형성하기에 충분한 애트리뷰트들을 갖지 못한 엔티티 타입
  - 약한 엔티티 타입에게 키 애트리뷰트를 제공하는 엔티티 타입을 소유 엔티티 타입 또는 식별 엔티티 타입이라고 부름
  - 이중선 직사각형으로 표기
  - 부분 키 : 부양 가족의 이름처럼 한 사원에 속한 부양가족 내에서는 서로 다르지만 회사 전체 사원들의 부양가족들 전체에서는 같은 경우가 생길 수 있는 애트리뷰트

- 카디날리티
  - 카디날리티 비율은 한 엔티티가 참여할 수 있는 관계의 수를 나타냄
  - 관계 타입에 참여하는 엔티티들의 가능한 조합을 제한
  - 간선 위에 나타냄

- 역할 (role)
  - 관계 타입의 의미를 명확하게 하기 위해 사용됨
  - 특히 하나의 관계 타입에 하나의 엔티티 타입이 여러 번 나타나는 경우에는 반드시 역할을 표기해야 함
  - 관계 타입의 간선 위에 표시

- 전체 참여와 부분 참여
  - 전체 참여는 어떤 관계에 엔티티 타입 E1의 모든 엔티티들이 관계 타입 R에 의해 어떤 엔티티 타입 E2의 어떤 엔티티와 연관되는 것을 의미
  - 부분 참여는 어떤 관계에 엔티티 타입 E1의 일부 엔티티만 참여하는 것을 의미



## 5.2 복잡한 ER 다이어그램의 예

- ER 모델의 또 다른 표기법
  - 본 장에서 사용한 표기법으로 수십 개 이상의 애트리뷰트가 엔티티 타입에 연결된 다이어그램을 나타내려면 매우 불편하고 공간을 많이 차지
  - ERWin 등의 CASE 도구들에서는 새발(crow-feet)표기법이 흔히 사용됨
- ER 스키마를 관계 모델의 릴레이션으로 사상
  - 논리적 설계 단계에서는 ER 스키마를 관계 데이터 모델의 릴레이션들로 사상
  - ER 스키마에는 엔티티 타입과 관계 타입이 존재하지만 관계 데이터베이스에는 엔티티 타입과 관계 타입을 구분하지 않고 릴레이션만 있음



## 5.4 ER 스키마를 관계 모델의 릴레이션으로 사상

- ER-관계 사상 알고리즘

  단계 1: 정규 엔티티 타입과 단일 값 애트리뷰트

  - ER 스키마의 각 정규 엔티티 타입 E에 대해 하나의 릴레이션 R 생성
  - E에 있던 단순 애트리뷰트들을 릴레이션 R에 모두 포함시킴
  - E에서 복합 애트리뷰트는 그 복합 애트리뷰트를 구성하는 단순 애트리뷰트들만 릴레이션 R에 포함시킴
  - E의 기본 키가 릴레이션 R의 기본 키가 됨

  단계 2: 약한 엔티티 타입과 단일 값 애트리뷰트

  - ER 스키마에서 소유 엔티티 타입 E를 갖는 각 약한 엔티티 타입 W에 대해 릴레이션 R을 생성함
  - W에 있던 모든 단순 애트리뷰트들을 릴레이션 R에 포함시킴
  - 소유 엔티티 타입에 해당하는 릴레이션의 기본 키를 약한 엔티티 타입에 해당하는 릴레이션에 외래 키로 포함시킴

  단계 3: 2진 1:1 관계 타입

  - ER 스키마의 각 2진 1:1 관계 타입 R에 대해, R에 참여하는 엔티티 타입에 대응되는 릴레이션 S와 T를 찾음
  - S와 T 중 한 릴레이션을 선택하여 만일 S를 선택했다면 T의 기본 키를 S에 외래 키로 포함 시킴
  - S와 T 중에서 관계 타입에 완전하게 참여하는 릴레이션을 S 역할을 하는 릴레이션으로 선택

  단계 4: 정규 2진 1:N 관계 타입

  - 정규 2진 1:N 관계 타입 R에 대해 N측의 참여 엔티티 타입에 대응되는 릴레이션 S를 찾음
  - 관계 타입 R에 참여하는 1측의 엔티티 타입에 대응되는 릴레이션 T의 기본키를 릴레이션 S에 외래키로 포함시킴
  - N측의 릴레이션 S의 기본 키를 1측의 릴레이션 T에 외래키로 포함시키면 애트리뷰트에 값들의 집합이 들어가거나 정보의 중복이 많이 발생함

  단계 5: 2진 M:N 관계 타입

  - 2진 M:N 관계 타입 R에 대해서는 릴레이션 R을 생성
  - 참여 엔티티 타입에 해당하는 릴레이션들의 기본 키를 릴레이션 R에 외래 키로 포함시키고, 이들의 조합이 릴레이션 R의 기본 키가 됨

  단계 6: 3진 이상의 관계 타입

  - 3진 이상의 각 관계 타입 R에 대해 릴레이션 R을 생성
  - 관계 타입 R에 참여하는 모든 엔티티 타입에 대응되는 릴레이션들의 기본키를 릴레이션 R에 외래키로 포함시킴
  - 일반적으로 외래 키들의 조합이 릴레이션 R의 기본키가 됨

  단계 7: 다치 애트리뷰트

  - 각 다치 애트리뷰트에 대해 릴레이션 R 생성
  - 다치 애트리뷰트에 해당하는 애트리뷰트를 릴레이션 R에 포함시키고 다치애트리뷰트를 애트리뷰트로 갖는 엔티티 타입이나 관계 타입에 해당하는 릴레이션의 기본 키를 릴레이션 R에 외래 키로 포함시킴
  - 릴레이션 R의 기본 키는 다치 애트리뷰트와 외래키의 조합