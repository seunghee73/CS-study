#### 트랜잭션 개요
- 트랜잭션(transaction)
    - 대규모 데이터베이스를 수백, 수천 명이 동시에 접근
    - 많은 사용자들이 동시에 데이터베이스의 서로 다른 부분 또는 동일한 부분을 접근하면서 데이터베이스 사용
    - 동시성 제어(concurrency control)
        - 동시에 수행되는 트랜잭션들이 데이터베이스에 미치는 영향은 이들을 순차적으로 수행하였을 때 데이터베이스에 미치는 영향과 같도록 보장
        - 다수 사용자가 데이터베이스를 동시에 접근하도록 허용하면서 데이터베이스의 일관성 유지
    - 회복(recovery)
        - 데이터베이스를 갱신하는 도중에 시스템이 고장 나도 데이터베이스의 일관성을 유지
    - DBMS가 추가로 정보를 유지하지 않는다면 DBMS가 재가동된 후에 어느 직원의 tuple까지 수정되었는가를 알 수 없음 > 로그(log) 유지

<br>

    - 트랜잭션 특성(ACID 특성)
        - 원자성(Atomicity) 
            - 한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않음(all or nothing)을 의미
            - **DBMS의 회복 모듈**은 시스템이 다운되는 경우에, 부분적으로 데이터베이스를 갱신한 트랜잭션의 영향을 취소함으로써 트랜잭션의 원자성을 보장
            - 완료된 트랜잭션이 갱신한 사항은 트랜잭션의 영향을 재수행함으로써 트랜잭션의 원자성을 보장
        - 일관성(Consistency)
            - 어떤 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태 > 트랜잭션이 수행된 후에 데이터베이스는 또 다른 일관된 상태를 가짐
            - 트랜잭션이 수행되는 도중에는 데이터베이스가 **일시적으로** 일관된 상태를 갖지 않을 수 있음
            - **DBMS의 동시성 제어**와 **무결성 제약조건**으로부터 보장을 받음
        - 고립성(Isolation)
            - 한 트랜잭션이 데이터를 갱신하는 동안 이 트랜잭션이 완료되기 전에는 갱신 중인 데이터를 다른 트랜잭션들이 접근하지 못하도록 해야 함
            - 다수의 트랜재션들이 동시에 수행되더라도 그 결과는 어떤 순서에 따라 트랜잭션들을 하나씩 차례대로 수행한 결과와 같아야 함
            - **DBMS의 동시성 제어 모듈**이 트랜잭션의 고립성을 보장
        - 지속성(Durability)
            - 일단 한 트랜잭션이 완료되면 이 트랜잭션이 갱신한 것은 그 후에 시스템에 고장이 발생하더라도 손실되지 않음
            - 완료된 트랜잭션의 효과는 시스템이 고장난 경우에도 데이터베이스에 반영
            - **DBMS의 회복** 모듈은 시스템이 다운되는 경우에도 트랜잭션의 지속성을 보장

<br>

   - 트랜잭션의 완료(commit)
       - 트랜잭션이 성공적으로 끝났음
       - 트랜잭션에서 변경하려는 내용이 데이터베이스에 완전하게 반영됨
       - 데이터베이스는 새로운 일관된 상태를 가짐
       - SQL 구문상으로 COMMIT WORK

<br>

   - 트랜잭션의 철회(abort)
       - 트랜잭션의 일부를 성공적으로 끝내지 못했음
       - 데이터베이스가 불일치 상태를 가질 수 있음
       - 트랜잭션이 수행한 갱신이 데이터베이스에 일부 반영되었다면 취소 해야함
       - 트랜잭션에서 변경하려는 내용이 데이터베이스에 일부만 반영된 경우에는 원자성을 보장하기 위해서, 트랜재션이 갱신한 사항을 트랜잭션이 수행되기 전의 상태로 되돌림
       - SQL 구문상으로 ROLLBACK WORK
  
<br>

    - 트랜잭션이 성공하지 못하는 원인
        - 시스템(사이트) 고장 : 중앙 처리 장치, 주기억 장치, 전원 공급 장치 등이 고장
        - 트랜잭션 고장 : 트랜잭션 고장은 트랜잭션이 수행되는 도중에 철회
        - 매체 고장 : 디스크 헤드, 디스크 콘트롤러 등이 고장나서 보조 기억 장치의 전부 또는 일부 내용이 지워짐
        - 통신 고장
        - 자연적 재해
        - 부주의 또는 고의적인 고장

<br>

#### 동시성 제어
    - 동시성 제어
        - 대부분의 DBMS들은 다수 사용자용
        - 여러 사용자들이 동시에 동일한 테이블을 접근하기도 함
        - DBMS의 성능을 높이기 위해 여러 사용자의 질의나 프로그램들을 동시에 수행하는 것이 필수적
        - 동시성 제어 기법은 여러 사용자들이 다수의 트랜잭션들을 동시에 수행하는 환경에서 부정확한 결과를 생성할 수 있는, 트랜잭션들 간의 간섭이 생기지 않도록 함
        - 직렬 스케줄(serial schedule) : 여러 트랜잭션들의 집합을 한 번에 한 트랜잭션씩 차례대로 수행
        - 비직렬 스케줄(non-serial schedule) : 여러 트랜잭션들을 동시에 수행
        - 직렬가능(serializable) : 비직렬 스케줄의 결과가 어떤 직렬 스케줄의 수행 결과와 동등
        - 동시성 제어를 하지 않고 다수의 트랜잭션을 동시에 수행할 때 가능한 문제
            - 갱신 손실(lost update) : 수행 중인 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어 씀으로써 갱신이 무효가 되는 것
            - 오손 데이터 읽기(dirty read) : 완료되지 않은 트랜잭션이 갱신한 데이터를 읽는 것
            - 반복할 수 없는 읽기(unrepeatable read) : 한 트랜잭션이 동일한 데이터를 두 번 읽을 때 서로 다른 값을 읽는 것
    - 로킹(locking)
         - 데이터 항목을 로킹하는 개념은 동시에 수행되는 트랜잭션들의 동시성을 제어하기 위해서 가장 널리 사용되는 기법
         - 로크는 데이터베이스 내의 각 데이터 항목과 연관된 하나의 변수
         - 각 트랜잭션이 수행을 시작하여 데이터 항목을 접근할 때마다 요청한 로크에 관한 정보는 lock table 등에 유지
         - 트랜잭션에서 갱신을 목적으로 데이터 항목을 접근할 때는 **독점 로크(X-lock, eXclusive lock)**를 요청
         - 트랜잭션에서 읽을 목적으로 데이터 항목을 접근할 때는 **공유 로크(S-lock, Shared lock)**를 요청
         - 트랜잭션이 데이터 항목에 대한 접근을 끝낸 후에 lock를 해제(unlock)함

<br>

    - 2단계 로킹 프로토콜(2-phase locking protocol)
        - 로크를 요청하는 것과 로크를 해제하는 것이 2단계로 이루어짐
        - 로크 확장 단계가 지난 후에 로크 수축 단계에 들어감
        - 일단 로크를 한 개라도 해제하면 로크 수축 단계에 들어감
        - 로크 확장 단계(1단계)
            - 로크 확장 단계에서는 트랜잭션이 데이터 항목에 대하여 새로운 로크를 요청할 수 있지만 보유하고 있던 로크를 하나라도 해제할 수 없음
        - 로크 수축 단계(2단계)
            - 로크 수축 단계에서는 보유하고 있던 로크를 해제할 수 있지만 새로운 로크를 요청할 수 없음
            - 로크 수축 단계에서는 로크를 조금씩 해제할 수도 있고 트랜잭션이 완료 시점에 이르렀을 때 한꺼번에 모든 로크를 해제할 수도 있음
            - 일반적으로 한꺼번에 해제하는 방식 사용
        - 로크 포인트는 한 트랜잭션에서 필요로 하는 모든 로크를 걸어놓은 시점

<br>

    - 데드록(deadlock)
        - 2단계 로킹 프로토콜에서는 데드록이 발생할 수 있음
        - 데드록은 두 개 이상의 트랜잭션들이 서로 상대방이 보유하고 있는 로크를 요청하면서 기다리고 있는 상태를 말함
        - 데드록을 해결하기 위해서는 데드록을 방지하는 기법이나, 데드록을 탐지하고 희생자를 선정하여 데드록을 푸는 기법 등을 사용함

<br>

    - 다중 로크 단위(multiple granularity)
        - 대부분의 트랜잭션들이 소수의 tuple을 접근하는 데이터베이스 응용에서는 tuple 단위로 로크를 해도 로크 테이블을 다루는 시간이 오래 걸리지 않음
        - 트랜잭션들이 많은 tuple을 접근하는 데이터베이스 응용에서 tuple 단위로만 로크를 한다면 로크 테이블에서 로크 충돌을 검사하고, 로크 정보를 기록하는 시간이 오래 걸림
        - 트랜잭션이 접근하는 tuple의 수에 따라 로크를 하는 데이터 항목의 단위를 구분하는 것이 필요
        - 한 트랜잭션에서 로크할 수 있는 데이터 항목이 두 가지 이상 있으면 다중 로크 단위라고 말함
        - 데이터베이스에서 로크할 수 있는 단위로는 데이터베이스, 릴레이션, 디스크 블록, 투플 등
        - 일반적으로 DBMS는 각 트랜잭션에서 접근하는 투플 수에 따라 자동적으로 로크 단위를 조정
        - 로크 단위가 작을수록 로킹에 따른 오버헤드 증가
        - 로크 단위가 작을수록 동시성의 정도는 증가
 
<br>

    - 팬텀 문제(phantom problem)
        - relation에 lock을 걸지 않고 index에 lock을 걸어서 해결

<br>

#### 회복
- 회복의 개요
    - 여러 응용이 주기억 장치 버퍼 내의 동일한 데이터베이스 항목을 갱신한 후에 디스크에 기록함으로써 성능을 향상시키는 것이 중요
    - 버퍼의 내용을 디스크에 기록하는 것을 가능하면 최대한 줄이는 것이 일반적
    - 트랜잭션이 버퍼에는 갱신 사항을 반영했지만 버퍼의 내용이 디스크에 기록되기 전에 고장이 발생할 수 있음
    - 고장이 발생하기 전에 트랜잭션이 완료 명령을 수행했다면 회복 모듈은 이 트랜잭션의 갱신 사항을 재수행(REDO)하여 트랜잭션의 갱신이 지속성을 갖도록 해야함
    - 고장이 발생하기 전에 트랜잭션이 완료 명령을 수행하지 못했다면 원자성을 보장하기 위해서 이 트랜잭션이 데이터베이스에 반영했을 가능성이 있는 갱신 사항을 취소(UNDO)해야 함

<br>

- 저장 장치의 유형
    - 주기억 장치와 같은 휘발성 저장 장치에 들어 있는 내용은 시스템이 다운된 후에 모두 사라짐
    - 디스크와 같은 비휘발성 저장 장치에 들어 있는 내용은 디스크 헤드 등이 손상을 입지 않는 한 시스템이 다운된 후에도 유지
    - 안전 저장 장치(stable storage)는 모든 유형의 고장을 견딜 수 있는 저장 장치를 의미
    - 두 개 이상의 비휘발성 저장 장치가 동시에 고장날 가능성이 매우 낮으므로 비휘발성 저장 장치에 두 개 이상의 사본을 중복해서 저장함으로써 안전 저장 장치를 구현

<br>

- 재해적 고장과 비재해적 고장
    - 재해적 고장
        - 디스크가 손상을 입어서 데이터베이스를 읽을 수 없는 고장
        - 재해적 고장으로부터의 회복은 데이터베이스를 백업해 놓은 자기 테이프를 기반으로 함
    - 비재해적 고장
        - 그 외의 고장
        - 대부분의 회복 알고리즘들은 비재해적 고장에 적용
        - 로그를 기반으로 한 즉시 갱신, 로그를 기반으로 한 지연 갱신, 그림자 페이징(shadow paging) 등 여러 알고리즘
        - 대부분의 상용 DBMS에서 로그를 기반으로 한 즉시 갱신 방식을 사용

<br>

- 로그를 사용한 즉시 갱신
    - 즉시 갱신에서는 트랜잭션이 데이터베이스를 갱신한 사항이 주기억 장치의 버퍼에 유지되다가 트랜잭션이 완료되기 전이라도 디스크의 데이터베이스에 기록될 수 있음
    - 데이터베이스에는 완료된 트랜잭션의 수행 결과 뿐만 아니라 철회된 트랜잭션의 수행 결과도 반영될 수 있음
    - 트랜잭션의 원자성과 지속성을 보장하기 위해서 DBMS는 **로그**라고 부르는 특별한 파일을 유지
    - 데이터베이스의 항목에 영향을 미치는 모든 트랜잭션의 연산들에 대해서 로그 레코드를 기록
    - 각 로그 레코드는 로그 순서 번호(LSN: Log Sequence Number)로 식별

<br>

#### 해싱
- 해싱(hashing) 방법
    - 다른 레코드의 참조 없이 목표 레코드의 접근을 직접 지원 (direct file)
    - 키(key) 값과 레코드의 주소(address) 사이의 사상(mapping) 관계를 함수로 설정
    - 해싱 함수(hashing function)
        - 키(key) 값으로부터 레코드 주소(address)를 계산
        - 사상 함수(mapping function) : 키 > 주소
        - 삽입, 검색에 모두 이용

<br>

- 버킷 해싱
    - 버킷(bucket)
        - 하나의 주소를 가지면서 하나 이상의 레코드를 저장할 수 있는 파일의 한 구역
        - 버킷 크기 : 저장 장치의 물리적 특성과 한 번 접근으로 채취 가능한 레코드 수를 고려
        - 버킷 해싱 : 키 > 버킷 주소
        - 충돌(collision) : 상이한 레코드들을 같은 주소(버킷)로 변환
            - 동거자(synonym) : 같은 버킷에 있는 레코드들
            - 버킷 만원 - 오버플로 버킷
            - 한 번의 I/O가 추가됨

<br>

- 확장성 해싱(extendibe hashing)
    - 충돌에 대처하기 위해 제안된 기법
    - 레코드 검색은 최대 2번의 디스크 접근만 필
    - 모조 키(pseudokey)
    - 디렉터리(directory)
        - 헤더에 현재의 디렉터리 깊이 d를 유지
        - d : 전역 깊이(global depth)
    - 버킷(bucket)
        - 헤더에 현재의 깊이 p를 유지
        - 각 버킷에 저장된 레코드들의 모조 키드은 처음 p 비트가 모두 동일
    - 삭제
        - 삭제할 레코드를 찾아 삭제
        - 한 버킷에 하나만 있는 레코드를 삭제하는 경우 : 버디(buddy) 버킷을 검사하여, 두 버디에 있는 레코드들이 하나의 버킷으로 들어갈 수 있으면 합병하고 빈 버킷은 반환
        - 버디 버킷(buddy bucket) : 두 버킷이 똑같은 버킷 깊이 p를 가지고 있고 저장된 레코드 모조 키들의 처음 (p - 1) 비트들이 모두 같은 버킷
        - 원래 하나의 버킷에서 분할된 두 버킷








