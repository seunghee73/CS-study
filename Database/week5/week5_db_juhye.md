## 9장. 트랜잭션

- 트랜잭션(transaction)
  - 항공기 예약, 은행, 신용 카드 처리, 대형 할인점 등에서는 대규모 데이터베이스를 수백, 수천 명 이상의 사용자들이 동시에 접근함
  - 많은 사용자들이 동시에 데이터베이스의 서로 다른 부분 또는 동일한 부분을 접근하면서 데이터베이스를 사용함
  - 동시성 제어(concurrency control)
    - 동시에 수행되는 트랜잭션들이 데이터베이스에 미치는 영향은 이들을 순차적으로 수행하였을 때 데이터베이스에 미치는 영향과 같도록 보장
    - 다수 사용자가 데이터베이스를 동시에 접근하도록 허용하면서 데이터베이스의 일관성을 유지함
  - 회복(recovery)
    - 데이터베이스를 갱신하는 도중에 시스템이 고장 나도 데이터베이스의 일관성을 유지함

### 9.1 트랜잭션 개요

- 데이터베이스 시스템 환경에서 흔히 볼 수 있는 몇 가지 응용의 예
  - DBMS가 추가로 정보를 유지하지 않는다면 DBMS가 재가동된 후에 어느 직원의 튜플까지 수정되었는가를 알 수 없음 -> 로그(log) 유지
- 트랜잭션의 특성(ACID 특성)
  - 원자성(Atomicity)
    - 한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않음(all or nothing)을 의미
    - DBMS의 회복 모듈은 시스템이 다운되는 경우에, 부분적으로 데이터베이스를 갱신한 트랜잭션의 영향을 취소함으로써 트랜잭션의 원자성을 보장함
    - 완료된 트랜잭션이 갱신한 사항은 트랜잭션의 영향을 재수행함으로써 트랜잭션의 원자성을 보장함
  - 일관성(Consistency)
    - 어떤 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태를 가졌다면 트랜잭션이 수행된 후에 데이터베이스는 또 다른 일관된 상태를 가짐
    - 트랜잭션이 수행되는 도중에는 데이터베이스가 일시적으로 일관된 상태르 갖지 않을 수 있음
  - 고립성(Isolation)
    - 한 트랜잭션이 데이터를 갱신하는 동안 이 트랜잭션이 완료되기 전에는 갱신 중인 데이터를 다른 트랜잭션들이 접근하지 못하도록 해야 함
    - 다수의 트랜잭션들이 동시에 수행되더라도 그 결과는 어떤 순서에 따라 트랜잭션들을 하나씩 차례대로 수행한 결과와 같아야 함
    - DBMS의 동시성 제어 모듈이 트랜잭션의 고립성을 보장함
    - DBMS는 응용들의 요구사항에 따라 다양한 고립 수준(isolation level)을 제공함
  - 지속성(Durability)
    - 일단 한 트랜잭션이 완료되면 이 트랜잭션이 갱신한 것은 그 후에 시스템에 고장이 발생하더라도 손실되지 않음
    - 완료된 트랜잭션의 효과는 시스템이 고장난 경우에도 데이터베이스에 반영됨
    - DBMS의 회복 모듈은 시스템이 다운되는 경우에도 트랜잭션의 지속성을 보장함
- 트랜잭션의 완료(commit)
  - 트랜잭션에서 변경하려는 내용이 데이터베이스에 완전하게 반영됨
  - SQL 구문상으로 COMMIT WORK
- 트랜잭션의 철회(abort)
  - 트랜잭션에서 변경하려는 내용이 데이터베이스의 일부만 반영된 경우에는 원자성을 보장하기 위해서, 트랜잭션이 갱신한 사항을 트랜잭션이 수행되기 전의 상태로 되돌림
  - SQL 구문상으로 ROLLBACK WORK

- 트랜잭션이 성공하지 못하는 원인
  - 시스템(사이트) 고장
    - 중앙 처리 장치, 주기억 장치, 전원 공급 장치 등이 고장남
  - 트랜잭션 고장
    - 트랜잭션 고장은 트랜잭션이 수행되는 도중에 철회됨
  - 매체 고장
    - 디스크 헤드, 디스크 콘트롤러 등이 고장 나서 보조 기억 장치의 전부 또는 일부 내용이 지워짐
  - 통신 고장
  - 자연적 재해
  - 부주의 또는 고의적인 고장

### 9.2 동시성 제어

- 동시성 제어
  - 대부분의 DBMS들은 다수 사용자용
  - 여러 사용자들이 동시에 동일한 테이블을 접근하기도 함
  - DBMS의 성능을 높이기 위해 여러 사용자의 질의나 프로그램들을 동시에 수행하는 것이 필수적
  - 동시성 제어 기법은 여러 사용자들이 다수의 트랜잭션들을 동시에 수행하는 환경에서 부정확한 결과를 생성할 수 있는, 트랜잭션들 간의 간섭이 생기지 않도록 함
- 동시성 제어를 하지 않고 다수의 트랜잭션을 동시에 수행할 때 생길 수 있는 문제
  - 갱신 손실(lost update): 수행 중인 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어 씀으로써 갱신이 무효가 되는 것
  - 오손 데이터 읽기(dirty read): 완료되지 않은 트랜잭션이 갱신한 데이터를 읽는 것
  - 반복할 수 없는 읽기(unrepeatable read): 한 트랜잭션이 동일한 데이터를 두 번 읽을 때 서로 다른 값을 읽는 것
- 로킹(locking)
  - 데이터 항목을 로킹하는 개념은 동시에 수행되는 트랜잭션들의 동시성을 제어하기 위해서 가장 널리 사용되는 기법
  - 로크(lock)는 데이터베이스 내의 각 데이터 항목과 연관된 하나의 변수
  - 각 트랜잭션이 수행을 시작하여 데이터 항목을 접근할 때마다 요청한 로크에 관한 정보는 로크 테이블(lock table) 등에 유지됨
  - 트랜잭션에서 갱신을 목적으로 데이터 항목을 접근할 때는 독점 로크(X-lock, eXclusive lock)을 요청함
  - 트랜잭션에서 읽을 목적으로 데이터 항목을 접근할 때는 공유 로크(S-lock, shared lock)를 요청함
  - 트랜잭션이 데이터 항목에 대한 접근을 끝낸 후에 로크를 해제(unlock)함
- 2단계 로킹 프로토콜(2-phase locking protocol)
  - 로크를 요청하는 것과 로크를 해제하는 것이 2단계로 이루어짐
  - 로크 확장 단계가 지난 후에 로크 수축 단계에 들어감
  - 일단 로크를 한 개라도 해제하면 로크 수축 단계에 들어감
  - 로크 확장 단계(1단계)
    - 로크 확장 단계에서는 트랜잭션이 데이터 항목에 대하여 새로운 로크를 요청할 수 있지만 보유하고 있던 로크를 하나라도 해제할 수 없음
  - 로크 수축 단계(2단계)
    - 로크 수축단계에서는 보유하고 있던 로크를 해제할 수 있지만 새로운 로크를 요청할 수 없음
    - 로크 수축단계에서는 로크를 조금씩 해제할 수도 있고 트랜잭션이 완료 시점에 이르렀을 때 한꺼번에 모든 로크를 해제할 수도 있음
    - 일반적으로 한꺼번에 해제하는 방식이 사용됨
  - 로크 포인트(lock point)는 한 트랜잭션에서 필요로 하는 모든 로크를 걸어놓은 시점
- 데드록(deadlock)
  - 2단계 로킹 프로토콜에서는 데드록이 발생할 수 있음
  - 데드록은 두 개 이상의 트랜잭션들이 서로 상대방이 보유하고 있는 로크를 요청하면서 기다리고 있는 상태를 말함
  - 데드록을 해결하기 위해서는 데드록을 방지하는 기법이나, 데드록을 탐지하고 희생자를 선정하여 데드록을 푸는 기법 등을 사용함
- 다중 로크 단위
  - 대부분의 트랜잭션들이 소수의 투플들을 접근하는 데이터베이스 응용에서는 투플 단위로 로크를 해도 로크 테이블을 다루는 시간이 오래 걸리지 않음
  - 트랜잭션들이 많은 투플을 접근하는 데이터베이스 응용에서 투플 단위로만 로크를 한다면 로크 테이블에서 로크 충돌을 검사하고, 로크 정보를 기록하는 시간이 로개 럴림
  - 트랜잭션이 접근하는 투플의 수에 따라 로크를 하는 데이터 항목의 단위를 구분하는 것이 필요함
  - 한 트랜잭션에서 로크할 수 있는 데이터항목이 두 가지 이상 있으면 다중 로크 단위라고 말함
  - 데이터베이스에서 로크할 수 있는 단위로는 데이터베이스, 릴레이션, 디스크 블록, 투플 등

### 9.3 회복

- 회복의 필요성
  - 어떤 트랜잭션 T를 수행하는 도중에 시스템이 다운되었을 때, T의 수행 효과가 디스크의 데이터베이스에 일부 반영되었을 수 있음
  - 또한 트랜잭션 T가 완료된 직후에 시스템이 다운되면 T의 모든 갱신 효과가 주기억 장치로부터 디스크에 기록되지 않았을 수 있음
  - 디스크의 헤드 등이 고장 나서 디스크의 데이터베이스를 접근할 수 없다면 어떻게 할 것인가?
- 회복의 개요
  - 여러 응용이 주기억 장치 버퍼 내의 동일한 데이터베이스 항목을 갱신한 후에 디스크에 기록함으로써 성능을 향상시키는 것이 중요함
  - 버퍼의 내용을 디스크에 기록하는 것을 가능하면 최대한 줄이는 것이 일반적
    - 예: 버퍼가 꽉 찼을 때 또는 트랜잭션이 완료될 때 버퍼의 내용이 디스크에 기록될 수 있음
  - 트랜잭션이 버퍼에는 갱신 사항을 반영했지만 버퍼의 내용이 디스크에 기록되기 전에 고장이 발생할 수 있음
- 저장 장치의 유형
  - 주기억 장치와 같은 휘발성 저장 장치에 들어 있는 내용은 시스템이 다운된 후에 모두 사라짐
  - 디스크와 같은 비휘발성 저장 장치에 들어 있는 내용은 디스크 헤드 등이 손상을 입지 않는 한 시스템이 다운된 후에도 유지됨
  - 안전 저장 장치(stable storage)는 모든 유형의 고장을 견딜 수 있는 저장 장치를 의미
  - 두 개 이상의 비휘발성 저장 장치가 동시에 고장날 가능성이 매 낮으므로 비휘발성 저장 장치에 두 개 이상의 사본을 중복해서 저장함으로써 안전 저장 장치를 구현함
- 재해적 고장과 비재해적 고장
  - 재해적 고장
    - 디스크가 손상을 입어서 데이터베이스를 읽을 수 없는 고장
    - 재해적 고장으로부터의 회복은 데이터베이스를 백업해 놓은 자기 테이프를 기반으로 함
  - 비재해적 고장
    - 그 이외의 고장
    - 대부분의 회복 알고리즘들은 비재해적 고장에 적용됨
    - 로그를 기반으로 한 즉시 갱신, 로그를 기반으로 한 지연 갱신, 그림자 페이징(Shadow paging) 등 여러 알고리즘
    - 대부분의 상용 DBMS에서 로그를 기반으로 한 즉시 갱신 방식을 사용
- 로그를 사용한 즉시 갱신
  - 즉시 갱신에서는 트랜잭션이 데이터베이스를 갱신한 사항이 주기억 장치의 버퍼에 유지되다가 트랜잭션이 완료되기 전이라도 디스크의 데이터베이스에 기록될 수 있음
  - 데이터베이스에는 완료된 트랜잭션의 수행 결과뿐만 아니라 철회된 트랜잭션의 수행 결과도 반영될 수 있음
  - 트랜잭션의 원자성과 지속성을 보장하기 위해 DBMS는 로그라고 부르는 특별한 화일을 유지함
  - 데이터베이스의 항목에 영향을 미치는 모든 트랜잭션의 연산들에 대해서 로그 레코드를 기록함
  - 각 로그 레코드는 로그 순서 번호(LSN: Log Sequence Number)로 식별됨





## 10. 데이터베이스의 저장과 접근: 해싱빅데이터 관리 서론

### 해싱(hashing) 방법

- 다른 레코드의 참조 없이 목표 레코드의 접근을 직접 지원
  - 직접 화일(direct file)
- 키(key) 값과 레코드 주소(address) 사이의 사상(mapping) 관계를 함수로 설정
- 해싱 함수(hashing function)
  - 키(key) 값으로부터 레코드 주소(address)를 계산
  - 사상 함수(mapping function) : 키 -> 주소
  - 삽입, 검색에 모두 이용

### 버킷 해싱

- 버킷(bucket)
  - 하나의 주소를 가지면서 하나 이상의 레코드를 저장할 수 있는 화일의 한 구역
  - 버킷 크기: 저장 장치의 물리적 특성과 한번 접근으로 채취 가능한 레코드 수를 고려
- 버킷 해싱: 키 -> 버킷 주소
- 충돌(collision): 상이한 레코드들을 같은 주소(버킷)로 변환
  - 동거자(synonym)
  - 버킷 만원 - 오버플로 버킷
  - 한번의 I/O가 추가됨

### 확장성 해싱 (extendible hashing)

- 충돌에 대처하기 위해 제안된 기법
- 레코드 검색은 최대 2번의 디스크 접근만 필요
- 모조 키(pseudo key)
  - 확장성 해싱 함수: 키 값 일정 길이의 비트 스트링, pseudokey로 변환
  - pseudokey의 처음 d 비트를 디렉터리의 인덱스로 사용
- 디렉터리(directory)
  - 헤더에 현재의 디렉터리 깊이 d를 유지
    - d: 전역 깊이(global depth)
  - 2^d개의 버킷들을 지시할 수 있는 포인터 엔트리로 구성
  - 디스크에 저장

### 확장성 해싱

- 버킷
  - 헤더에 현재의 버킷 깊이 p를 유지
    - p : 지역 깊이 (local depth)
  - 각 버킷에 저장된 레코드들의 모조 키들은 처음 p 비트가 모두 동일



### 버킷 오버플로 예

- 모조키가 10으로 시작하는 레코드를 저장. 네 번째 버킷은 오버플로
- 빈 버킷을 할당하고 버킷을 분할 : 버킷의 깊이 p는 모두 2로 설정
  - 오버플로된 버킷에는 모조키 10으로 시작하는 레코드만 남김
  - 새 버킷에는 모조키 11로 시작하는 레코드를 이동시켜 저장
- 디렉터리의 110과 111의 포인터 값이 새 버킷을 지시하도록 조정

