| Week 1 | Lecture 1~3 |
| :----: | :---------: |

<br/>

<br/>

# 관계 대수와 SQL

---

<br/>

- 관계해석: 원하는 데이터만 명시하고 질의를 어떻게 수행할 것인가는 명시하지 않는 선언적인 언어
- 관계대수: 어떻게 질의를 수행할 것인가를 명시하는 절차적인 언어
- SQL: 사용자는 SQL을 사용하여 관계 데이터베이스에 릴레이션을 정의하고, 정보를 검색하고 갱신하며 여러가지 무결성 제약조건들을 명시할 수 있음

### 관계 대수

- 기존의 릴레이션들로부터 새로운 릴레이션을 생성
- 릴레이션이나 관계 대수식에 연산자들을 적용하여 보다 복잡한 관계 대수식을 점차적으로 만들 수 있음
- 기본적인 연산자들의 집합으로 이루어짐
- 산술 연산자와 유사하게 단일 릴레이션이나 두 개의 릴레이션을 입력으로 받아 하나의 결과 릴레이션을 생성
- 결과 릴레이션은 또 다른 관계 연산자의 입력으로 사용
- selection 연산자
  - 한 릴레이션에서 selection 조건을 만족하는 튜플들의 부분 집합을 생성함
  - 단항 연산자
  - 결과 릴레이션의 차수는 입력 릴레이션의 차수와 같음
  - 결과 릴레이션의 cardinality는 항상 원래 릴레이션의 cardinality보다 작거나 같음
  - selection 조건을 predicate라고도 함
  - selection 조건은 일반적으로 릴레이션의 임의의 attribute와 상수, =, <>, <=, < ,>=, > 등의 비교 연산자, AND, OR, NOT 등의 부울 연산자를 포함할 수 있음

- projection 연산자
  - 한 릴레이션의 attribute들의 부분 집합을 구함
  - 결과로 생성되는 릴레이션은 attribute list에 명시된 attribute들만 가짐
  - selection의 결과 릴레이션에는 중복 tuple이 존재할 수 없지만 projection연산의 결과 릴레이션에는 중복된 tuple들의 존재할 수 있음

- 집합 연산자
  - 릴레이션이 tuple들의 집합이기 때문에 기존의 집합 연산이 릴레이션에 적용됨
  - 합집합, 교집합, 차집합 연산자
  - 집합 연산자의 입력으로 사용되는 두 개의 릴레이션은 합집합 호환이어야 함
    - 두 릴레이션이 합집합 호환일 필요 충분 조건은 n=m이고 모든 1<=i<=n에 대해 domain(Ai)=domain(Bi)

  - 이항 연산자

- 관계 대수의 완전성
  - selection, projection, 합집합, 차집합, 카티션 곱은 관계 대수의 필수적인 연산자
  - 다른 관계 연산자들은 필수적인 관계 연산자를 두 개 이상 조합하여 표현할 수 있음
  - 임의의 질의어가 적어도 필수적인 관계 대수 연산자들만큼의 표현력을 갖고 있으면 관계적으로 완전하다고 말함

- 조인 연산자
  - 두 개의 릴레이션으로부터 연관된 tuple들을 결합하는 연산자
  - 관계 데이터베이스에서 두 개 이상의 릴레이션들의 관계를 다루는데 매우 중요
  - theta join: =, <>, <=, <, >=, > 중 하나
  - equijoin: theta join 중에서 비교 연산자가 =인 조인
  - natural join: equijoin의 결과 릴레이션에서 join attribute를 제외한 조인, 자주 사용
  - outer join, semijoin

- 디비전 연산자
- 관계 대수의 한계
  - 관계 대수는 산술 연산을 할 수 없음
  - aggregate function을 지원하지 않음
  - 정렬 나타낼 수 없음
  - 데이터베이스를 수정할 수 없음
  - projection 연산의 결과에 중복된 tuple을 나타내는 것이 필요할 때가 있는데 이를 명시하지 못함

- 추가된 관계 대수 연산자
  - 집단 함수
  - 그룹화
  - 오른쪽 외부 조인
  - 왼쪽 외부 조인
  - 완전 외부 조인


<br/>

### SQL 개요

- SQL 개요
  - SQL은 관계 DBMS가 압도적인 우위를 차지하는데 중요한 요인
  - SQL은 관계 대수와 관계 해석을 기반으로 집단 함수, 그룹화, 갱신 연산 등을 추가하여 개발된 언어
  - SQL은 비절차적 언어 이므로 사용자는 자신이 원하는 바만 명시하며 원하는 것을 처리하는 방법(how)는 명시할 수 없음
  - 자연어에 가까운 구문을 사용하여 질의를 표현할 수 있음
  - 대화식 SQL(interactive SQL), 내포된 SQL(embedded SQL)
  - SQL 구성요소: 데이터 정의어, 데이터 조작어, 데이터 제어어

<br/>


### 데이터 정의어와 무결성 제약조건

- 데이터 정의어
  - 스키마의 생성과 제어
- 릴레이션 제거 DROP TABLE ~
- ALTER TABLE ~ ADD ~
- 인덱스 생성 CREATE INDEX ~ ON ~
- 도메인 생성 CREATE DOMAIN ~ DEFAULT ~

<br/>

### SELECT문

- 관계 데이터베이스에서 정보를 검색하는 SQL문
- 관계 대수의 Selection과 의미가 완전히 다름
- 관계 대수의 selection, projection, join, 카티션 곱 등을 결합한 것
- 관계 데이터베이스에서 가장 자주 사용됨
- SELECT ~ FROM ~
- NULL
  - 널 값을 포함한 다른 값과 널값을 +, - 등을 사용하여 연산하면 결과는 NULL
  - COUNT(*)를 제외한 집단 함수들은 NULL값 무시
  - DNO IS NULL 이 올바른 표현(DNO = NULL은 옳지 않은 표현)

- 집단 함수
  - 데이터베이스에서 검색된 여러 tuple들의 집단에 적용되는 함수
  - 한 릴레이션의 한 개의 attribute에 적용되어 단일 값을 반환
  - SELECT절과 HAVING절에만 나타날 수 있음
  - COUNT(*)를 제외하고는 NULL값을 제거한 후 남아 있는 값들에 대해서 집단 함수의 값을 구함
  - COUNT(*)는 결과 릴레이션의 모든 행들의 총 개수를 구하는 반면에 COUNT(attribute)는 해당 attribute에서 NULL값이 아닌 값들의 개수를 구함
  - 키워드 DISTINCT가 집단 함수 앞에 사용되면 집단 함수가 적용되기 전에 먼저 중복을 제거

- 그룹화
  - GROUP BY절에 사용된 attribute에 동일한 값을 갖는 tuple들이 각각 하나의 그룹으로 묶임
  - grouping attribute
  - 각 그룹에 대하여 결과 릴레이션에 하나의 tuple이 생성됨
  - SELECT 절에는 각 그룹마다 하나의 값을 갖는 attribute, 집단 함수, 그룹화에 사용된 attribute들만 나타날 수 있음

- 집합 연산
  - 집합 연산을 적용하려면 두 릴레이션이 합집합 호환성을 가져야 함
  - UNION, EXCEPT, INTERSECT, UNION ALL, EXCEPT ALL, INTERSECT ALL

- 조인
  - 두 개 이상의 릴레이션으로부터 연관된 tuple을 결합
  - 먼저 조인 조건을 만족하는 tuple들을 찾고, 이 tuple들로 부터 SELECT절에 명시된 attribute들만 project하고 필요하다면 중복을 배제
  - 조인 조건을 생략했을 때와 조인 조건을 틀리게 표현했을 때는 카티션 곱이 생성됨
  - 릴레이션 이름이나 tuple 변수를 사용하여 구분해주는 것이 바람직

- 중첩 질의
  - 외부 질의의 WHERE절에 다시 SELECT ~ FROM ~ WHERE 형태로 포함된 SELECT문
  - 중첩 질의의 결과로 한 개의 스칼라 값(단일 값), 한 개의 attribute로 이루어진 릴레이션, 여러 attribute로 이루어진 릴레이션이 반환될 수 있음
    - 여러 attribute로 이루어진 릴레이션이 반환되는 경우 EXISTS 연산자를 사용하여 중첩 질의의 결과 빈 릴레이션인지 확인

  - 상관 중첩 질의
    - 중첩 질의의 WHERE절에 있는 프레디키트에서 외부 질의에 선언된 릴레이션의 외부 attribute를 참조하는 질의
    - 외부 질의로 한번만 결과를 반환하면 상관 중첩 질의가 아님
    - 외부 질의를 만족하는 tuple수만큼 여러번 수행될 수 있음


<br/>

### INSERT, DELETE, UPDATE

- INSERT
  - 기존의 릴레이션에 tuple을 삽입
  - 참조되는 릴레이션에 tuple이 삽입되는 경우에 참조 무결성 제약 조건의 위배가 발생하지 않으나 릴레이션에 tuple이 삽입되는 경우에는 참조 무결성 제약 조건을 위배할 수 있음
  - 릴레이션에 한 번에 한 tuple씩 삽입하는 것과 한 번에 여러개의 tuple들을 삽입할 수 있는 것으로 구분

- DELETE
  - 삭제 연산은 한 릴레이션으로부터 한 개 이상의 tuple을 삭제
  - 참조되는 릴레이션의 삭제 연산의 결과로 참조 무결성 제약조건이 위배될 수 있으나 참조하는 릴레이션에서 tuple을 삭제하면 참조 무결성 제약조건을 위배하지 않음

- UPDATE
  - 한 릴레이션에 들어 있는 tuple들의 attribute 값들을 수정
  - 기본 키나 외래 키에 속하는 attribute의 값이 수정되면 참조 무결성 제약조건을 위배할 수 있음


<br/>

### 트리거와 주장

- 트리거
  - 명시된 이벤트가 발생할 때마다 DBMS가 자동적으로 수행하는 사용자가 정의하는 문(프로시저)
  - 데이터베이스의 무결성을 유지하기 위한 일반적이고 강력한 도구
  - 테이블 정의시 표현할 수 없는 기업의 비즈니스 규칙들을 시행
  - 트리거를 명시하려면 트리거를 활성화시키는 사건인 이벤트, 트리거가 활성화되었을 때 수행되는 테스트인 조건, 트리거가 활성화되고 조건이 참일 때 수행되는 문인 동작을 표현해야 함
  - 이벤트-조건-동작 규칙
  - 이벤트의 가능한 예로는 테이블에 tuple 삽입, tuple 삭제, tuple 수정 등이 있음
  - 조건은 임의의 형태의 프레드키트
  - 동작은 데이터베이스에 대한 임의의 갱신
  - 어떤 이벤트가 발생했을 때 조건이 참이 되면 트리거와 연관된 동작이 수행되고 그렇지 않으면 아무런 동작도 수행되지 않음
  - 삽입, 삭제, 수정 등이 일어나기 전에 동작하는 트리거와 후에 동작하는 트리거로 구분
- 주장
  - SQL3에는 포함되어 있으나 대부분의 상용 관계 DBMS가 아직 미지원
  - 트리거는 제약조건을 위반했을 때 수행할 동작을 명시하는 것이고 주장은 제약조건을 위반하는 연산이 수행되지 않도록 함
  - CREATE ASSERTION 이름 CHECK 조건
  - 트리거보다 좀더 일반적인 무결성 제약조건
  - DBMS는 주장의 프레드키트를 검사하여 만일 참이면 주장을 위배하지 않는 경우이므로 데이터베이스 수정이 허용됨
  - 일반적으로 두 개 이상의 테이블에 영향을 미치는 제약조건을 명시하기 위해 사용됨

<br/>

### 내포된 SQL

- 내포된 SQL
  - SQL이 호스트 언어의 완전한 표현력을 갖고 있지 않기 때문에 모든 질의를 SQL로 표현할 수는 없음
  - 호스트 언어에 포함되는 SQL문을 내포된 SQL이라 부름
  - 데이터 구조가 불일치하는 문제
  - MS SQL SERVER 2005에서 C언어에 SQL문을 내포시키는 환경을 ESQL/C라 부름
  - 호스트 언어로 작성중인 프로그램에 SQL문을 내포시킬 때 SQL문 앞에 EXEC SQL을 붙여 구분
  - ESQL/C 전컴파일러는 내포된 SQL문을 C컴파일러에서 허용되는 함수 호출로 변환
    - ESQL/C
      - 정적인SQL문과 동적인SQL문 모두 지원
      - 정적인 SQL문은 C 프로그램에 내포된 완전한 Transact-SQL문
      - 동적인 SQL문은 불완전한 Transact-SQL문으로서 일부 또는 전부를 질의가 수행될 때 입력 가능
      - 정적인 SQL문은 입력값과 출력 데이터를 위해서 C 프로그램의 변수들을 포함할 수 있음
      - SQL문에 포함된 C 프로그램의 변수를 호스트 변수라고 부름

<br/>

<br/>

