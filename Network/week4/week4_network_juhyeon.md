# 링크계층

## Wireless Network 무선이동네트워크

### IEEE 802.11 frame

- 무선 인터넷은 free 주파수 대역을 사용
- 거기서 채널을 나눠서 사용
- 다른 채널끼리는 충돌 X
- 같은 채널을 쓰는 AP끼리 다른 AP여도 똑같이 CSMA/CA 방식으로 경쟁해서 데이터를 보냄
- 무선 인터넷 프레임의 헤더에는 address 필드가 4개 有
  - address1: 데이터를 받을 AP의 MAC 주소
  - address2: 데이터를 보내는 host의 MAC 주소
  - address3: 데이터를 받을 라우터의 MAC 주소
- AP는 한쪽은 무선(와이파이), 한쪽은 유선(이더넷) 데이터를 받을 때랑 전송할 때랑 프레임 헤더가 바뀜
- AP는 링크 계층까지만 지원하는 기기(link layer device), host 입장에서 AP가 보이지만 라우터 입장에서는 AP가 보이지 않음(스위치 같은 개념)
- AP는 host의 프레임을 받아서 자기 자신 AP 주소(address1)을 빼고 dest 주소를 라우터의 주소(address3)으로, source 주소를 host의 주소(address2)로 설정 후 프레임을 전달



- 왜 주소를 3개씩 보낼까?
  - address3이 없을 경우,  AP는 링크 계층까지만 존재하기 때문에 해당 프레임을 열고 IP 패킷을 봐도 목적지 IP 주소로 가기 위해 보내야할 다음 라우터의 MAC 주소를 알 수가 없음그래서 어디로 보내야 할지 알지 못함
  - address1이 없을 경우, AP 자체를 찾지 못함
  - 무선 헤더에는 주소 3개가 다 있어야함



- 데이터를 받을 때도 이더넷 프레임을 와이파이 프레임을 바꿔줘야 됨

- 라우터가 source는 자기 자신, 목적지는 host 주소로 보내면, AP가 중간에 받아서

  - address1: 데이터를 받을 host의 MAC 주소
  - address2: 데이터를 보내는 AP의 MAC 주소
  - address3: 데이터를 보낸 라우터의 MAC 주소

  로 프레임 변경 후 전송



결국 AP가 링크 계층까지만 존재해서 주소 하나를 더 추가해서 라우터의 정보를 담아 주는 것



- 주소 구하는 방법
  - address2는 자기 자신이라 알기 쉬움
  - address1은 AP가 주기적으로 전송하는 비콘 메시지로 알 수 있음
  - address3은 DCHP를 통해 얻은 라우터의 IP 주소로 ARP 프로토콜을 사용해 구함



- 무선일때 DHCP 동작 과정
  - 프레임에 AP, host, 브로드캐스트를 담고 IP 패킷에는 sour는 비워두고 dest는 브로드캐스트로 보냄
  - dest는 브로드캐스트, sour은 host인 이더넷 프레임으로 바꿔서 전달
  - DCHP 포트가 열려있는 DHCP 서버만 받아서 다시 브로드캐스트로 생성된 IP 주소 전달
  - 이때 IP 패킷의 dest이 브로드캐스트면 프레임의 desc도 브로드캐스트임 => MAC 주소를 아는 방법은 가지고 있는 IP 주소를 ARP 테이블에 매칭해서 알아내기 때문
  - DCHP 포트가 열려있고 트랜잭션 ID가 동일한 host만 받아서 IP 주소를 생성
  - DHCP 과정에서 AP의 ARP 테이블에 라우터의 MAC 주소가 등록되기 때문에 다시 또 ARP 리퀘스트를 보낼 필요는 없음



- AP는 공유기인가?
  - 큰 회사일 경우 하나의 라우터에 여러 AP를 연결해서 사용
  - 집에서 사용하는 공유기는 AP역할과 라우터 역할을 모두 담당



#### mobility within same subnet

- 인터넷 사용 중 이동을 해서 AP가 변경될때
  - TCP 커넥션은 본인 IP 주소, port, 목적지 IP 주소, port가 바뀌지 않으면 연결 유지
  - IP만 바뀌지 않으면 연결 유지
  - AP만 바꼈을 뿐 같은 서브넷 안에 있기 때문에 IP가 바뀌지 않음



- 라우터는 내가 이동하는 줄 모르기 때문에 똑같이 sour에는 라우터 주소, dest에는 내 주소를 적어서 프레임을 보냄
- 스위치는 그 프레임을 받아서 스위치 테이블을 참고해서 데이터를 보냄, 이때 이 스위치 테이블만 바꿔주면 됨
- 이동을 해서 AP가 바뀔때 더미 프레임을 하나 보내서 나와 라우터 사이에 연결된 스위치들의 스위치 테이블 정보를 경신



### Cellular Internet access

- 전체 담당하는 지역으르 셀로 나눠서 셀 하나에 기지국 하나 심어놓고 그 셀을 속하는 host들을 담당해서 cellular network라고 불림
- host와 기지국은 무선으로 연결되어 있고 기지국과 라우터는 유선으로 연결되어 있음



#### Multiple access techniques

- 2G 시절에는 FDMA/TDMA 방식을 사용했음, 보내는 통로를 나누거나 보내는 시간을 나눠서 전송하게 함
- 3G부터는 CDMA를 사용, 각자 원할때 보내게 하되 수학적 기법을 사용해서 자기 자신의 신호는 잘 들리고 남의 신호는 노이즈 처리함 => 충돌 X



#### Cellular evolution

- 2G, 3G, 4G 를 나누는 기준은 속도
- 1Gbps의 속도를 제공하는 기술은 4G, LTE-A
- 5G는 약 20Gbps의 속도를 냄, 4G의 20배
- 5G 등 새로운 기술이 나오기 전 이미 개발은 완료된 상태, 여러 기술 중 하나의 기술만이 사용화됨, 4G는 LTE가 낙점
- 삼성이 필두로 개발한 Wibro 기술도 4G를 지원했으나 아예 새로운 환경을 구축해야하는 등의 어려움 때문에 LTE에 밀림



## Mobility

이동 중에도 네트워크가 끊기지 않게 개발된 기술, 실제 상용화 X



- mobility의 3단계
  1. 이동 없이 한 곳에서만 인터넷 사용
  2. 이동은 하지만 TCP 연결을 끊고 이동 후 다시 새로운 TCP 연결, TCP 연결을 유지할 필요는 없음
  3. TCP 연결을 유지한 체로 이동



- 네트워크를 넘나드는 유저가 있는데, 어떻게 TCP 커넥션을 유지시켜줄 수 있을까?
  1. 이동하는 대상과 어떻게 연결을 할 것인가
  2. 계속 이동할때 어떻게 연결을 유지시킬 것인가
     - 한 곳에서 인터넷으 사용하지 않고 계속 이동하는 유저라면 어떻게 처음 연결을 시켜줄지와 어떻게 연결 후 계속 이동하면서도 연결을 이어주게 할지 이 2가지 문제를 해결해야함



### vocabulary

- home network: host를 일단 한 곳에 홈 네트워크(permanent)를 만들고, 이동할때마다 permanent에게 위치를 알려주면 연결할 때 위치를 찾아가서 연결 시켜줌
- home agent: home network를 관리하는 라우터



- 이동이 발생했을 때 host는 home의 주소(permanet address)와 이동한 곳의 주소(care-of-address) 둘 다 가지고 있게 됨
- host가 이동하면 foreign agent에게 알려줌, foreign agent는 home agent에게 host가 자기 쪽에 있다는 사실을 알림
- host에 연결하고자 하면 permanent address에 보냄, home agent는 그걸 받아서 fordign agent로 redirect forward를 함
- 이 경우 연결은 쉬우나 데이터가 돌아가서 시간이 오래 걸림
- 이동할 때마다 home agent에게 자기 위치를 전달하면 계속 커넥션 유지 가능



# Multimedia networking

## Audio

멀티미디어 서비스가 제공하는 첫번째 기능

- 아날로그 시그널을 디지털 신호로 변환하는 작업을 sampling 이라고 함
- 자연스러운 소리를 정영화된 비트로 변환하는 작업
- 샘플링 주기를 짧게 하면 짧게 할수록, 샘플링할 때 비트수가 많으면 많을수록 더 완벽하게 아날로그 소리와 같아짐
- 1초에 나타내는 비트양: CD는 1.411 Mbps, MPS는 96, 128, 160 kbps, CD가 더 고음질



## Video

- 비디오는 이미지의 연속, 초당 나타내는 이미지 횟수가 많을수록 고화질
- 이미지는 곧 프레임, 프레임에는 해당 이미지에도 모든 픽셀 정보가 담겨있음
- 근처 픽셀끼리는 같은 색을 가지고 있어서 중복되는 픽셀은 압축시켜서 프레임에 저장
- 초당 나타내는 프레임 수를 coding rate라고 함



- 멀티미디어 네트워크의 3가지 타입
  1. streaming, stored: 서버에 저장되어있는 오디오, 비디오를 틀어줌(유튜브, 넷플릭스)
  2. conversational: voice/video over IP(스카이프)
  3. streaming live: 라이브 송출



### Streaming stored video

- 서버에서 주는 그대로 host에서 플레이를 하는게 베스트, 하지만 네트워크 상황때문에 바로 송출하기는 어려움
- host는 서버에서 받은 데이터를 바로 송출하지 ㅇ낳고 잠시 버퍼에 담았다가 해당 버퍼가 어느정도 차면 그때 송출(버퍼링)
- UDP는 네트워크 상황을 고려 안하니 네트워크 상황이 나쁠경우 하나도 제대로 가지 않아서 사용하기 어려움
- TCP는 또 너무 네트워크 상황에만 의존해서 컨트롤 하기 어려움
- 그래서 멀티미디어 서비스에서는 TCP 기반의 DASH라는 프로토콜을 사용



#### DASH

Dynamic, Adaptive, Streaming over HTTP

- 2GB 짜리 영화가 있을 때 2GB를 통채로 저장하는게 아니라 256kb 등 작은 단위(chunks)로 쪼갬

- 각 chunks를 하나의 버전으로 인코딩하는 것이 아닌 128, 256, 512kbps, 1, 2, 5mbps 등으로 인코딩

- 각 chunks 별 인코딩된 url을 담아놓는 테이블을 manifest file 이라고 함

- 사용자가 영상을 틀때 128 kbps부터 틀어줌, 네트워크 상황을 판단해서 괜찮으면 인코딩 버전을 점점 늘리고 상황이 안좋으면 낮춤

- youtube 같은 경우 동시 사용자가 많음, 모든 영상이 한곳에 저장되어 있으면 요청이 너무 많아져 수용을 못하는 문제가 발생

  - 파일 저장 서버를 한 곳에 두는 것이 아닌 전세계에 두는 CDN 방식 사용
  - 사용자가 요청이 오면 메인 서버는 manifest file만 넘겨주고 사용자는 근처서버에서 데이터를 받아옴

  

  사용자마다 같은 manifest file을 받는데 각각 다른 서버에서 데이터를 받아올 수 있는가

  - manifest file url을 찾아가려면 해당 IP를 알아야함
  - DNS 쿼리를 보내 해당 IP를 알 수 있음



# Network Security  네트워크 보안

## 네트워크 보안의 4가지 요소

1. confidentiality: 기밀성, 센더와 리시버의 통신 내용을 제 3자가 알아서는 안됨
2. authentication: 인증, 상대방을 확신할 수 있어야 함
3. message integrity: 중간에 메세지 변경이 일어나면 안됨
4. access and availability: 데이터 통신은 24시간 내내 누구에게나 이뤄질 수 있어야 함

이런 요소들은 OSI 계층 어디에도 포함되어 있지 않음

새로운 문제가 생길때마다 각 계층에 필요한 패치를 추가하는 방식으로 보안 구축



Wireshark 툴을 사용하면 IP 패킷의 sour, desc와 TCP 세그먼트의 헤더, 메세지 다 보임(HTTPS는 메세지 감춤)



## The language of cryptography

### symmetric key 방식

- 앨리스랑 밥이 plaintext(m)를 주고 받을때
- 암호화하기 위해서는 2가지의 key가 필요함
- 암호화 하는 key(Ka(m))와 해독하는 key(Kb(Ka(m)))
- 앨리스와 밥이 같은 key를 갖고 있어 앨리스가 보낼때 해당 key로 암호화 하고 밥이 받을때 해당 key로 해독
- 데이터 통신 전에 어떤 key를 써서 암호화 할건지 사전 협의하는 작업 필요

- 사전 합의 없이 암호화를 하기 위해 모든 인터페이스마다 2가지 종류의 key를 갖게 함
- 모든 사람에게 공개되는 public key, 자기 자신만 볼 수 있는 private key
- 앨리스는 공개된 public key로 밥에게 메세지를 보내면 밥은 자기 자신만 볼 수 있는 private key로 암호 해독
- 이 방식을 RSA78
- RSA 특징 중 하나는 key의 순서가 상관 없다는 것, public key, private key 둘중 어느 것을 먼저 적용시키나 똑같은 메세지를 볼 수 있음
- RSA는 key를 하나만 가지는 암호화 방식보다 몇천배의 시간이 더 소요
- 처음에 symmetric key를 사용하기 위해 어떤 key를 쓸건지 정할때만 RSA 방식을 사용하고 key가 정해진 다음에는 symmetric key 방식으로 통신



### Authentication

- symmetric key 혹은 RSA 방식을 사용하면 내가 보내는 데이터를 다른 사람이 알아차리지 못하게 상대방에게만 전할 수 있음
- 하지만 그 발신자를 믿을 수 있는지에 대해 검증해야 함



- 앨리스가 데이터를 보내고 밥이 받으면 확인하기 위해 랜덤한 숫자(R)를보낸ㅁ
- 앨리스는 그 숫자를 암호화해서 밥에게 보냄, 밥이 그걸 받아 해독한 후 R과 같으면 앨리스인지 확인할 수 있음