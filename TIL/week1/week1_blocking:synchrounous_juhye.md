## Blocking vs Non-Blocking

### Blocking

- 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 다른 작업이 끝날 때까지 기다렸다가 자신의 작업을 시작하는 것
- 요청이 마무리될 때까지 멈춰있음

### Non-Blocking

- 다른 주체의 작업에 관련없이 자신의 작업을 하는 것
- 코드를 향상하기 위해서 사용

---

## Synchrounous vs Asynchrounous

### Synchrounous

- 동시에 일어나는 
- 1개 작업을 완료한 후 다음 작업을 수행하는 순차적인 방식
- 요청을 하면 바로(동시에) 응답(결과)을 받음
- 요청을 하면 시간이 오래 걸려도 요청한 자리에서 결과가 주어져야 함
- A노드와 B노드 사이의 작업 처리 단위(transaction)을 동시에 맞춤
- 장점: 설계방식이 간단하고 직관적임
- 단점: 결과가 주어질 때까지 아무것도 못하고 대기해야 함

### Asynchrounous

- 동시에 일어나지 않는

- 다중 환경에서 여러 개의 작업이 선행 작업의 순서나 완료 여부와 상관없이 실행되는 방식

- 요청과 결과가 동시에 일어나지 않음

- 요청 내용에 대해 지금 바로 응답받지 않아도 됨

- 노드 사이의 작업 처리 단위(transaction)을 동시에 맞추지 않아도 됨

- 장점

  - 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 다른 작업이 가능하여 자원을 효율적으로 사용할 수 있음.
  - 페이지 리로드의 경우, 전체 리소스를 다시 불러오지 않고 필요한 부분만 불러와 사용할 수 있음

- 단점: 동기보다 설계방식이 복잡함

- 예시

  - Ajax 통신

  - setTimeout()

    ```javascript
    setTimeout(foo, 3000);
    
    function boo(){
      console.log("2");
    }
    console.log("1");
    ```

    boo함수는 setTimeout()함수의 콜백함수로, setTimeout() 함수를 호출한 후 3초 뒤에 boo() 함수가 수행된다. 콘솔에 1,2 순서로 출력됨.

    #### 콜백(callback) 함수

    비동기 방식에서 어떤 수행이 완료됐을 때 수행해야 할 함수