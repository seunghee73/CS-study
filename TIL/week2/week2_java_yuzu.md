#### 🎃 오토 박싱 & 오토 언박싱
- int, long, float, double, boolean과 Integer, Long, Float, Double, Boolean의 타입은 다르다. int, long, float, double, boolean은 기본 타입이고 Integer, Long, Float, Double, Boolean은 Wrapper 클래스이다.
- 기본 타입을 Wrapper 클래스로 만드는 것은 박싱이고, Wrapper 클래스를 기본 타입으로 만드는 것은 언박싱이다.
- JDK 1.5부터 박싱과 언박싱이 필요한 상황에 자동으로 처리해주지만 내부적으로 추가 연산 작업이 이뤄지므로 가능한 동일한 타입을 연산하는 것이 좋다.
<br>
#### 🎃 직렬화(Serialization)
- 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 변환하는 기술이다.
- 데이터를 통신 상에서 전송 및 저장하기 위해 직렬화/역직렬화를 사용한다.
- 자주 변경되는 클래스는 직렬화 사용을 지양한다.
- 클래스 변경을 개발자가 예측할 수 없을 때는 직렬화 사용을 지양한다.
- 개발자가 직접 컨트롤 할 수 없는 클래스(라이브러리 등)는 직렬화 사용을 지양한다.
- 역직렬화에 실패하는 상황에 대한 예외처리는 필수로 구현한다.
- 직렬화 데이터는 타입, 클래스 메타정보를 포함하므로 사이즈가 크다. 트래픽에 따라 비용 증가 문제가 발생할 수 있기 때문에 JSON 포맷으로 변경하는 것이 좋다.
<br>
#### 🎃 String VS StringBuffer VS StringBuilder
- String
	- new 연산을 통해 생성된 인스턴스의 메모리 공간은 변하지 않는다. (Immutable)
	- Garbage Collector로 제거되어야 한다.
	- 문자열 연산시 새로 객체를 만드는 Overhead가 발생한다.
	- 객체가 불변하므로 멀티쓰레드에서 동기화를 신경 쓸 필요가 없다. (조회 연산에 좋음)
- StringBuffer
	- new 연산으로 클래스를 한 번만 만든다. (Mutable)
	- 문자열 연산시 새로 객체를 만들지 않고 크기를 변경시킨다.
	- Multi-Thread 환경에서 주로 사용한다.
- StringBuilder
	- new 연산으로 클래스를 한 번만 만든다. (Mutable)
	- 문자열 연산시 새로 객체를 만들지 않고 크기를 변경시킨다.
	- Single-Thread 또는 Thread를 신경 안쓰는 환경에서 주로 사용한다.
<br>
#### 🎃 Access Modifier
- 변수 또는 메소드의 접근 범위를 설정해주기 위해 사용하는 Java의 예약어이다.
- public: 어떤 클래스에서라도 접근이 가능하다.
- protected: 클래스가 정의되어 있는 해당 패키지 내 그리고 해당 클래스를 상속받은 외부 패키지의 클래스에서 접근이 가능하다.
- (default): 클래스가 정의되어 있는 해당 패키지 내에서만 접근이 가능하도록 접근 범위를 제한한다.
- private: 정의된 해당 클래스에서만 접근이 가능하도록 접근 범위를 제한한다.
<br>
#### 🎃 Java 장단점
- 장점
    - 운영체제에 독립적: JVM에서 동작하기 때문에 플랫폼에 종속적이지 않다.
    - 객체지향 언어: 캡슐화, 상속, 추상화, 다형성 등을 지원하여 객체 지향 프로그래밍이 가능하다.
    - 동적 로딩을 지원: 애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 각 객체가 필요한 시점에 클래스를 동적 로딩해서 생성된다. 또한 유지보수 시 해당 클래스만 수정하면 되기 때문에 전체 애플리케이션을 다시 컴파일할 필요가 없다. 따라서 유지보수가 쉽고 빠르다.
- 단점
    - 비교적 느림: 한번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고 JVM에 의해 기계어로 번역되고 실행되는 과정을 거치기 때문에 조금 느리다.
<br>