## 3.3 프로세스와 스레드

- 프로그램의 컴파일 과정
  
  - 소스 코드 파일 > 전처리 > 컴파일러 > 어셈블리어 > 어셈블러 > 목적 코드 > 링커 > 실행 가능한 파일
  
  - 전처리 : 소스 코드의 주석을 제거하고 #include 등 헤더 파일을 병함하여 매크로를 치환
  
  - 컴파일러 : 오류처리, 코드 최적화 작업을 하며 어셈블리어로변환
  
  - 어셈블러 : 어셈브리어는 목적 코드(object code)로 변환
  
  - 링커 : 프로그램 내에 있는 라이브러리 함수 또는 다른 파일과 목적 코드를 결합하여 실행 파일 생성
    
    - 정적 라이브러리 : 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식
    
    - 동적 라이브러리 : 프로그램 실행 시 필요할 때만 DLL이라는 함수 정보를 통해 참조 > 메모리 효율성에서의 장점과 외부 의존도가 높아진다는 단점

- 프로세스의 상태
  
  - 생성(create) 상태
    
    - 프로세스가 생성된 상태
    
    - fork() : 부모 프로세스의 주소 공간을 그대로 복사하여 새로운 자식 프로세스 생성
    
    - exec() : 새롭게 프로세스를 생성하는 함수
    
    - PCB가 할당
  
  - 대기(ready) 상태
    
    - 메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 대기
    
    - CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태
  
  - 대기 중단(ready suspended) 상태
    
    - 메모리 부족으로 일시 중단된 상태
  
  - 실행(running) 상태
    
    - CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태를 의미
    
    - CPU burst
  
  - 중단(blocked) 상태
    
    - 어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태
    
    - I/O 디바이스에 의한 인터럽트로 많이 발생
  
  - 일시 중단(blocked suspended) 상태
    
    - 대기 중단과 유사
    
    - 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태
  
  - 종료 (terminated) 상태
    
    - 메모리와 CPU 소유권을 모두 놓고 가는 상태
    
    - 부모 프로세스가 자식 프로세스를 강제시키는 비자발적 종료로 종료
      
      - 자식 프로세스에 할당된 자원의 한계치를 넘어서서 종료
      
      - 부모 프로세스가 종료되거나 사용자가 process, kill 등 여러 명령어로 프로세스를 종료할때 발생



- 프로세스의 메모리 구조
  
  - 동적 영역
    
    - 스택 : 함수가 함수를 재귀적으로 호출하면서 동적으로 크기가 늘어날 수 있는데, 힙과 스택의 메모리 영역이 겹치면 안 되기 때문에 힙과 스택 사이의 공간을 비워 놓는다.
    
    - 힙 : 동적 할당할 때 사용되며 런타임 시 크기가 결정
  
  - 정적 영역
    
    - 데이터 영역(BSS segment, Data segment) : 전역 변수, 정적 변수가 저장되고 정적인 특징을 갖는 프로그램이 종료되면 사라지는 변수가 들어 있는 영역. BSS 영역은 초기화가 되지 않는 변수가 0으로 초기화되어 저장되며 DATA 영역은 0이 아닌 다른 값으로 할당된 변수들이 저장
    
    - 코드 영역
      
      - 프로그램에 내장되어 있는 소스 코드가 들어가는 영역



- PCB(Process Control Block)
  
  - 운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터
  
  - 메타데이터 : 데이터에 관한 구조화된 데이터이자 데이터를 설명하는 작은 데이터
  
  - PCB의 구조
    
    - 프로세스 스케줄링 상태
    
    - 프로세스 ID
    
    - 프로세스 권한
    
    - 프로그램 카운터
    
    - CPU 레지스터
    
    - CPU 스케줄링 정보
    
    - 계정 정보
    
    - I/O 상태 정보
  
  - 컨텍스트 스위치(context swtiching) : PCB를 교환하는 과정. 이 과정에 발생하는 비용을 캐시미스. 스레드에서도 발생





- 멀티 프로세싱
  
  - 여러 개의 프로세스를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것
  
  - 웹 브라우저
    
    - 브라우저 프로세스
    
    - 렌더러 프로세스
    
    - 플러그인 프로세스
    
    - GPU 프로세스
  
  - IPC(Inter Process Communication)
    
    - 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘
    
    - 클라이언트와 서버, 공유 메모리, 파일, 소켓, 익명 파이프, 명명 파이프, 메시지 큐
    
    -  익명 파이프 : 프로세스 간에 FIFO 방식으로 읽히는 임시 공간인 파이프를 기반으로 데이터를 주고 받으며, 단방향 방식의 읽기 전용, 쓰기 전용 파이프를 만들어서 작동, 부모와 자식 프로세스 간에만 사용 가능
    
    - 명명된 파이프 : 파이프 서버와 하나 이상의 파이프 클라이언트 간의 통신을 위한 명명된 단방향 또는 이중 파이프. 여러 파이프를 동시에 사용할 수 있음. 컴퓨터의 프로세스끼리 또는 다른 네트워크 상의 컴퓨터와도 통신
    
    - 메시지 큐 : 메시지를 큐 데이터 구조 형태로 관리하는 것





- 스레드와 멀티스레딩
  
  - 스레드 : 프로세스의 실행 가능한 가장 작은 단위, 프로세스는 여러 스레드를 가질 수 있다.
  
  - 멀티 스레딩 : 프로세스 내 작업을 여러 개의 스레드, 멀티 스레드로 처리하는 기법. 스레드끼리 서로 자원을 공유하기 떄문에 효율성이 높음. 하지만 한 스레드에 문제가 생기면 다른 스레드에도 영향을 미칠 수 있는 단점



- 공유자원과 임계 영역
  
  - 공유 자원
    
    - 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수 등을 의미
    
    - 경쟁 상태(race condition) : 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황
  
  - 임계 영역
    
    - 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 영역
    
    - 뮤텍스, 세마포어, 모니터 > 상호 배제, 한정 대기, 융통성
    
    - lock
    
    - 상호배제 : 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다
    
    - 한정 대기 : 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안 된다
    
    - 융통성 : 한 프로세스가 다른 프로세스의 일을 방해하면 안 된다.
    
    - 뮤텍스 : 공유 자원을 사용하기 전에 설정하고 사용한 후에 해제하는 잠금
    
    - 세마포어 : 일반화된 뮤텍스로 프로세스가 공유 자원에 접근하면 세마포어에서 wait() 작업을 수행하고 프로세스가 공유 자원을 해제하면 세마포어에서 signal() 작업 수행
      
      - wait() : 자신의 차례가 올 떄까지 기다리는 함수
      
      - signal() : 다음 프로세스로 순서를 넘겨주는 함수
      
      - 바이너리 세마포어 : 뮤텍스
      
      - 카운팅 세마포어 : 여러 자원에 대한 접근을 제어할 때 사용
    
    - 모니터 : 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공



- 교착 상태(deadlock)
  
  - 교착 상태의 원인
    
    - 상호 배제 : 한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근이 불가능
    
    - 점유 대기 : 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태
    
    - 비선점 : 다른 프로세스의 자원을 강제적으로 가져올 수 없음
    
    - 환형 대기 : 프로세스 A는 프로세스 B의 자원을 요구하고 프로세스 B는 프로세스 A의 자원 요구
  
  - 은행원 알고리즘 : 총 자원의 양과 현재 할당된 자원의 양을 기준으로 안정 또는 불안정 상태로 나누고 안정 상태로 가도록 자원을 할당하는 알고리즘





## CPU 스케줄링 알고리즘

- 비선점방식(non-preemptive)
  
  - 프로세스가 스스로 CPU 소유권을 포기하는 방식. 강제로 프로세스를 중지하지 않음. 컨텍스트 스위칭으로 인한 부하가 적음
  
  - FCFS : 가장 먼저 온 것을 가장 먼저 처리하는 알고리즘
  
  - SJF : 실행 시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘
  
  - 우선순위 : 오래된 작업일수록 우선순위를 높이는 방법(aging)을 통해 단점 보완

- 선점형 방식(preemptive)
  
  - 지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시켜 버리고 강제로 다른 프로세스에 CPU 소유권을 할당하는 방식
  
  - 라운드 로빈 : 각 프로세스는 동일한 할당 시간을 주고 그 시간 안에 끝나지 않으면 다시 준비 큐의 뒤로 가는 알고리즘
  
  - SRF : SJF는 중간에 실행 시간이 더 짧은 작업이 들어와도 기존 짧은 작업을 모두 수행하고 그 다음 짧은 작업을 이어가는데 SRF는 중간에 더 짧은 작업이 들어오면 수행하던 프로세스를 중지하고 해당 프로세스를 수행
  
  - 다단계 큐 : 우선 순위에 따른 준비 큐를 여러 개 사용하고 큐마다 라운드 로빈이나 FCFS 등 다른 스케줄링 알고리즘을 적용하는 것. 큐 간의 프로세스 이동이 안 되므로 스케줄링 부담이 적지만 유연성이 떨어지는 특징


