# Chapter 1. 디자인 패턴과 프로그래밍 패러다임

## 1.1 디자인 패턴

### 1.1.1 싱글톤 패턴

하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴

데이터베이스 연결 모듈에 많이 사용
인스턴스를 생성할 때 비용이 줄어드는 장점

의존성이 높아지다는 단점



#### 싱글톤 패턴의 단점

TDD할때 걸림돌

- TDD를 할때 단위 테스트가 서로 독립적이어야 하는데 독립적인 인스턴스를 만들기가 어려움



#### 의존성 주입

사용하기가 쉽고 굉장히 실용적이지만 모듈 간의 결합을 강하게 만들 수 있다는 단점

- 의존성 주입을 통해 해결

의존성 주입자가 이 부분을 가로채 메인 모듈이 '간접'적으로 의존성을 주입하는 방식

메인 모듈은 하위 모듈에 대한 의존성이 떨어지게 된다 = 디커플링이 된다



##### 의존성 주입의 장점

테스팅하기 쉽고 마이그레이션하기도 수월

애플리케이션 의존성 방향이 일관

애플리케이션을 쉽게 추론

모듈 간의 관게들이 조금 더 명확



##### 의존성 주입의 단점

모듈들이 더욱더 분리되므로 클래스 수가 늘어나 복잡성이 증가

런타임 패널티



##### 의존성 주입 원칙

상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 합ㄴ디ㅏ. 또한, 둘 다 추상화에 의존해야 하며, 이때 추상화는 세부 사항에 의존하지 말아야 합니다.



### 1.1.2 팩토리 패턴

객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴이자 상속 관게에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생서에 관한 구체적인 내용을 결정하는 패턴

느슨한 결합, 더 많은 유연성

객체 생성 로직이 따로 떼어져 있기 때문에 유지 보수성이 증가



Enum - 상수의 집합을 정의할 때 사용되는 타입, 코드 리팩터링 시 강점



### 1.1.3 전략 패턴

정책패턴

객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않고 전략이라고 부르는 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

ex) 네이버페이, 카카오 페이등 다양한 방법으로 결제, '전략'만 바꿔서 두 가지 방식으로 결제



##### passport의 전략 패턴

미들웨어 라이브러리



### 1.1.4 옵저버 패턴

주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패터

주체란 객체의 상태 변화를 보고 있는 관찰자

옵저버들이란 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 '추가 변화 사항'이 생기는 객체들

주체와 객체를 따로 두지 않고 상태가 변경되는 객체를 기반으로 구축하기도 함

ex) 트위터

주로 이벤트 기반 시스템에 사용하며 MVC패턴에도 사용

모델에서 변경 사항이 생겨 update() 메서드로 옵저버인 뷰에 알려주고 이를 기반으로 컨트롤러 등이 작동



##### 자바: 상속과 구현

**상속**

자식 클래스가 부모 클래스의 메서드 등을 상속

재용성, 중복성의 최소화

**구현**

부모 인터페이스를 자식 클래스에서 재정의하여 구현

반드시 부모 클래스의 메서드를 재정의하여 구현

**상속과 구현의 차이**

상속은 일반 클래스, abstract 클래스, 구현은 인터페이스를 기반



#### 자바스크립트에서의 옵저버 패턴

**프록시 객체**

어떠한 대상의 기본적인 동작의 작업을 가로챌 수 있는 객체

target: 프록시할 대상

handler: 프록시 객체의 target 동작을 가로채서 정의할 동작들이 정해져 있는 함수



##### Vue.js 3.0의 옵저버 패턴

자동으로 DOM에 있는 값이 변경

DOM(Document Object Model): 문서 객체 모델을 말하며, 웹 브라우저상의 화면을 이루고 있는 요소들을 지칭



### 1.1.5 프록시 패턴과 프록시 서버

#### 프록시 패턴

대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴

객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용

프록시 서버로도 활용



- 프록시 서버에서의 캐싱
  
  - 캐시 안에 정보를 담아두고, 캐시 안에 있는 정보를 요구하는 요청에 대해 다시 저 멀리 있는 우너격 서버에 요청하지 않고 캐시 안에 있는 데이터를 활용하는 것을 말한다. 이를 통해 불필요하게 외부와 연결하지 않기 때문에 트래픽을 줄일 수 있다는 장점이 있다.



#### 프록시 서버

서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램



**프록시 서버로 쓰는 nginx**

비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버

Node.js 서버 앞단의 프록시 서버로 활용

nginx를 프록시 서버로 둬서 실제 포트를 숨길 수 있고 정적 자우너을 gzip 압축하거나, 메인 서버 앞단에서의 로깅을 할 수도 있음



**버퍼 오버플로우**

버퍼는 보통 데이터가 저장되는 메모리 공간으로, 메모리 공간을 벗어나는 경우

이때 사용되지 않아야할 영역에 데이터가 덮어씌워져 주소, 값을 바꾸는 공격이 발생하기도 함



**gzip 압축**

DEFLATE 알고리즘을 기반으로 한 압축 기술

데이터 전송량을 줄일 수 있지만 압축을 해제했을 때 서버에서의 CPU 오버헤드도 생각해서 gzip 압축 사용 유무를 결정해야 함



**프록시 서버로 쓰는 CloudFlare**

분산된 서버가 있고 이를 통해 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN 서비스

DDOS 공격 방어, HTTPS 구축 가능

웹 서버 앞단에 두어 '프록시 서버'로 쓰기 때문에 가능한 것



**DDOS 공격 방어**

DDOS는 네트워크에 많은 요청을 보내 네트워크를 마비

트래픽을 자동으로 차단, 방화벽 대시보드 제공



**HTTPS 구축**

인증서를 기반으로 구축

인증서 설치 없이 좀 더 손쉽게 HTTPS 구축 가능



**CDN**

각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크

사용자가 웹 서버로부터 콘텐츠를 다운로드하는 시간을 줄일 수 있음



**CORS와 프런트에드의 프록시 서버**

CORS 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘



### 1.1.6 이터레이터 패턴

이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴

이터레이터라는 하나의 인터페이스로 순회가 가능



**이터레이터 프로토콜**

이터러블한 객체들을 순회할 때 쓰이는 규칙

**이터러블한 객체**

반복 가능한 객체로 배열을 일반화한 객체



### 1.1.7 노출모듈 패턴

즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴



### 1.1.8 MVC 패턴

모델, 뷰, 컨트롤러로 이루어진 디자인 패턴

개발  프로세스에서 각각의 구성 요소에만 집중해서 개발 가능

재사용성과 확장성이 용이

애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해진다는 단점



##### 모델

애플리케이션의 데이터인 데이터베이스, 상수, 변수



##### 뷰

사용자 인터페이스 요소

사용자가 볼 수 있는 화면

화면에 표시하는 정보만 가지고 있어야함



##### 컨트롤러

하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할

이벤트 등 메인 로직을 담당

모델과 뷰의 생명주기도 관리



##### MVC 패턴의 예 리액트

가상 DOM을 통해 실제 DOM을 조작하는 것을 추상화해서 성능을 높임

불변성



### 1.1.9 MVP 패턴

MVC 패턴으로부터 파생

컨트롤러가 프레젠터로 교체된 패턴

뷰와 프레젠터는 일대일 관계이기 때문에 더 강한 결합



### 1.1.10 MVVM 패턴

MVC의 C에 해당하는 컨트롤러가 뷰모델로 바뀐 패턴

뷰모델은 뷰를 더 추상화한 계층

커멘드와 데이터 바인딩을 가지는 것이 특징

UI를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉽다



ex) 뷰

반응형이 특징인 프런트엔드 프레임 워크

양방향 바인딩, html을 토대로 컴포넌트 구축 가능



## 1.2 프로그래밍 패러다임

프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론

jdk 1.8이전의 자바는 개체지향 프로그래밍을 지원하는 반면에 하스켈은 함수형 프로그래밍을 지원

선언형, 명령형

선언형 - 함수형

명령형 - 객체지향, 절차지향



### 1.2.1 선언형과 함수형 프로그래밍

**선언형 프로그래밍**이란 무엇을 풀어내는가에 집중하는 패러다임

프로그램은 함수로 이루어진 것이라는 명제가 담겨 있는 패러다임



**함수형 프로그래밍**은 선언형 패러다임의 일종  

작은 순수 함수들을 블록처럼 쌓아 로직을 구현하고 고차 함수를 통해 재사용성을 높인 프로그래밍 패러다임



#### 순수함수

출력이 입력에만 의존



#### 고차 함수

함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것

일급 객체

- 변수나 메서드에 함수를 할당할 수 있다

- 함수 안에 함수를 매개변수로 담을 수 있다

- 함수가 함수를 반환할 수 있다



### 1.2.2 객체지향 프로그래밍

객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식



#### 객체지향 프로그래밍의 특징

##### 추상화

복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것을 의미

##### 캡슐화

객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것

##### 상속성

상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것

코드의 재사용 측면, 계층적인 관계 생성, 유지 보수성 측면에서 중요

##### 다향성

하나의 메서드나 클래스가 다양한 방법으로 동작하는 것

오버로딩, 오버라이딩

##### 오버로딩

같은 이름을 가진 메서들르 여러개 두는 것

메서드의 타입, 매개변수의 유형, 개수

정적 다향성

##### 오버라이딩

메서드 오버라이딩을 말하며 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의하는 것을 의미

동적 다향성



#### 설계 원칙

SOLID 원칙

S - 단일 책임 원칙

O - 개방 폐쇄 원칙

L - 리스코프 치환 원칙

I - 인터페이스 분리 원칙

D - 의존역전 원칙



##### 단일 책임 원칙

SRP 모든 크래스는 각각 하나의 책임만 가져야하는 원칙

##### 개방-폐쇄 원칙

OCP, 유지 보수 사항이 생긴다면 코드를 쉽게 확장할 수 있도록 하고 수정할 때는 닫혀 있어야하는 원칙

##### 리스코프 치환 원칙

LSP, 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 하는 것을 의미

##### 인터페이스 분리 원칙

ISP, 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 하는 원칙

##### 의존 역전 원칙

DIP, 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 원칙



### 1.2.3 절차형 프로그래밍

코드의 가독성이 좋으며 실행 속도가 빠름

계산이 많으 작업에 사용

포트란 이용

모듈화하기 어렵고 유지 보수성이 떨어진다



### 1.2.4 패러다임의 혼합


