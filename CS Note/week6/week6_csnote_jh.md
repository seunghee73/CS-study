# 4. 데이터베이스

## 4.1 데이터베이스의 기본

데이터베이스 : 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음

DBMS: 데이터베이스를 제어, 관리하는 통합 시스템

데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어를 통해 삽입, 삭제, 수정, 조회 등을 수행 가능. 데이터베이스는 실시간 접근과 동시 공유가 가능

데이터베이스 위에 DBMS가 있고 그 위에 응용 프로그램이 있으며 이렇나 구조를 기반으로 데이터를 주고 받음

<br />

### 4.1.1 엔터티

사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사

**약한 엔터티와 강한 엔터티**

A가 혼자서 존재하지 못하고 B의 존재 여부에 따라 종속적이라면 A는 약한엔터티이고 B는 강한 엔터티

<br />

### 4.1.2 릴레이션

데이터베이스에서 정보를 구분하여 저장하는 기본 단위

엔터티에 관한 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리

릴레이션은 관계형 데이터베이스에서는 테이블이라고 하며, noSQL 데이터베이스에서는 컬렉션이라고 함

<br />

#### 테이블과 컬렉션

관계형 데이터베이스 / NoSQL 데이터베이스

MySql의 구조는 레코드-테이블-데이터베이스

NoSQL 데이터베이스의 구조는 도큐먼트-컬렉션-데이터베이스

<br />

### 4.1.3 속성

릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보

<br />

### 4.1.4 도메인

릴레이션에 포함된 각각의 속성들이 가질 수 없는 값의 집합

<br />

### 4.1.5 필드와 레코드

테이블에 쌓이는 행(row) 단위의 데이터를 레코드 = 튜플

<br />

#### 필드

타입을 가짐

- 숫자 타입
  
  - TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT

- 날짜 타입
  
  - DATE, DATETIME, TIMESTAMP
  
  - DATE
    
    - 날짜 부분은 있지만 시간 부분은 없는 값
    
    - 3바이트의 용량
  
  - DATETIME
    
    - 날짜 및 시간 부분을 모두 포함하는 값
    
    - 8바이트의 용량
  
  - TIMESTAMP
    
    - 날짜 및 시간 부분을 모두 포함하는 값
    
    - 4바이트의 용량

- 문자 타입
  
  - CHAR, VARCHAR, TEXT, BLOB, ENUM, SET
  
  - CHAR와 VARCHAR
    
    - 그 안에 수를 입력해서 몇 자까지 입력할지 정함
    
    - CHAR는 테이블을 생성할 때 선언한 길이로 고정되며 길이는 0에서 255 사이의 값
    
    - 레코드를 저장할 때 무조건 선언한 길이 값으로 고정해서 저장
    
    - VARCHAR는 가변 길이 문자열
    
    - 0에서 65,535 사이의 값으로 지정할 수 있으며 입력된 데이터에 따라 용량을 가변시켜 저장
    
    - CHAR의 경우 검색에 유리, 검색을 별로 하지 않고 유동적ㅇ니 길이를 가진 데이터는 VARCHAR로 저장
  
  - TEXT와 BLOB
    
    - 큰 데이터를 저장할때 쓰는 타입
    
    - TEXT는 큰 문자열 저장에 쓰며 주로 게시판의 본문을 저장할때 사용
    
    - BLOB은 이미지, 동영상 등 큰 데이터 저장에 사용
    
    - 서버에 파일을 올리고 파일에 관한 경로를 VARCHAR로 저장
    
    - ENUM과 SET
      
      - 문자열을 열거한 타입
      
      - ENUM은 
        
        - ENUM(x-small, small, medium, large, x-large) 형태로 쓰임
        
        -  하나만 선택하는 단일 선택만 가능하고 ENUM 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입
        
        - ENUM을 이용하면 x-small 등이 0, 1 등올 매핑되어 메모리를 적게 사용하는 이점
        
        - 최대 65,535개의 요소들
      
      - SET은
        
        - ENUM과 비슷하지만 여러 개의 데이터를 선택할 수 있고 비트 단위의 연산을 할 수 있으며 최대 64개의 요소를 집어넣을 수 있음
      
      - 공간적으로 이점을 볼 수 있지만 애플리케이션의 수정에 따라 데이터베이스이 ENUM이나 SET에서 정의한 목록을 수정해야 한다는 단점

<br />

### 4.1.6 관계

테이블은 서로의 관계가 정의, 관계화살표로 나타냄

<br />

#### 1:1 관계

<br />

#### 1:N 관계

한 개체가 다른 많은 개체를 포함하는 관계

<br />

#### N:M 관계

학생과 강의의 관게, 서로 여러개 가능

<br />

### 4.1.7 키

테이블 간의 관계를 조금 더 명확하게 하고 테이블 자체의 인덱스를 위해 설정된 장치로 기본키, 외래키, 후보키, 슈퍼키, 대체키

슈퍼키 > 후보키 > 기본키, 대체키

슈퍼키는 유일성이 있고 그 안에 포함된 후보키는 최소성까지 갖춘 키

후보키 중에서 기본키로 선택되지 못한 키는 대체키

유일성은 중복된 값은 없으며 최소성은 필드를 조합하지 않고 최소 필드만 써서 키를 형성할 수 있는 것

<br />

#### 기본키 PK

유일성과 최소성을 만족하는 키

- 자연키
  
  - 중복된 값들을 제외하며 중복되지 않는 것을 자연스레 뽑다가 나오는 키
  
  - 언젠가는  변하는 속성

- 인조키
  
  - 인위적으로 생성한 키
  
  - 자연키와는 대조적으로 변하지 않음
  
  - 보통 기본키는 인조키

<br />

#### 외래키 FK

다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계를 식별하는데 사용

외래키는 중복 가능

<br />

#### 후보키

candidate key, 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족하는 키

<br />

#### 대체키

alternate key, 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들

<br />

#### 슈퍼키

각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

<br />

## 4.2 ERD와 정규화 과정

데이터베이스를 구축할 때 가장 기초적인 뼈대 역할

릴레이션 간의 관계들을 정의한 것

서비스를 구축한다면 가장 먼저 신경 써야 할 부분

이부분을 신경 쓰지 않고 서비스를 구축한다면 단단하지 않은 골조로 건물을 짓는 것

<br />

### 4.2.1 ERD의 중요성

ERD는 시스템의 요구 사항을 기반으로 작성되며 이 ERD를 기반으로 데이터베이스를 구축

데이터베이스를 구축한 이후에도 디버깅 또는 비즈니스 프로세스 재설계가 필요한 경우에 설계도 역할을 담당

ERD는 관계형 구조로 표현할 수 있는 데이터를 구성하는 데 유용할 수 있지만 비정형 데이터를 충분히 표현할 수 없다는 단점

- 비정형 데이터
  
  - 비구조화 데이터를 말하며, 미리 정의된 데이터 모델이 없거나 미리 정의된 방식으로 정리되지 않은 정보

<br />

### 4.2.2 예제로 배우는 ERD

<br />

### 4.2.3 정규화 과정

릴레이션 간의 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나서 이를 해결하거나, 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정

**데이터베이스 이상 현상**이란 회원이 한 개의 등급을 가져야 하는데 세 개의 등급을 갖거나 삭제할 때 필요한 데이터가 같이 삭제되고, 데이터를 삽입해야 하는데 하나의 필드 값이 NULL이 되면 안 되어서 삽입하기 어려운 현상

정규형 원칙을 기반으로 정규형을 만들어가는 과정

정규화된 정도는 정규형(NF)로 표현

기본 정규형인 제1정규형, 제2정규형, 제3정규형, 보이스/코드 정규형

고급 정규형인 제 4정규형, 제5정규형

<br />

#### 정규형 원칙

같은 의미를 표현하는 릴레이션 이지만 좀 더 좋은 구조로 만들어야 함

자료의 중복성은 감소해야 함

독립적인 관계는 별개의 릴레이션으로 표현해야 함

각각의 독립적인 표현이 가능해야 함

<br />

#### 제1정규형

릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값만으로 구성되어야 함

릴레이션의 속성 값 중에서 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안 됨, 반복 집합이 있다면 제거

<br />

#### 제2정규형

릴레이션이 제1정규형이며 부분 함수의 종속성을 제거한 형태

부분 함수의 종속성 제거란 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것

릴레이션을 분해할 때 동등한 릴레이션으로 분해해야 하고, 정보 손실이 발생하지 않는 무손실 분해로 분해되어야 함

<br />

#### 제3정규형

제2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 상태

- 이행적 함수 종속
  
  - A -> B, B -> C가 존재하면 논리적으로 A -> C가 성립하는데 이때 C가 A에 이행적으로 함수 종속이 되었다

<br />

#### 보이스/코드 정규형

제3정규형

결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태

- 결정자
  
  - 함수 종속 관계에서 특정 종속자를 결정짓는 요소
  
  - X -> Y일때 X는 결정자, Y는 종속자

<br />

정규형 과정을 거쳐 테이블을 나눈다고 해서 성능이 무조건 좋아지진 않으므로 서비스에 따라 정규화 또는 비정규화 과정을 진행해야 함
