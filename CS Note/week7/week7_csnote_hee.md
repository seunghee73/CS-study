- 인덱스 

## 4.3 트랜잭션과 무결성

- 트랜잭션
  
  - 트랜잭션
    
    - 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
    - 여러 개의 쿼리들을 하나로 묶는 단위
    - 원자성, 일관성, 독립성, 지속성( ACID )
  
  - 원자성(atomicity)
    
    - all or nothing
    - 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장
    - 트랜잭션을 커밋했는데, 문제가 발생하여 롤백하는 경우 그 이후에 모두 수행되지 않음을 보장
    - 트랜잭션 단위로 여러 로직들을 묶을 때 외부 API를 호출하는 것이 있으면 안 된다. 만약 있는 경우에는 롤백이 일어났을 때 어떻게 해야할 것인지에 대한 해결 방법이 있어야하고 트랜잭션 전파를 신경 써서 관리
    - 커밋(commit) : 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어, 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장
    - 롤백(rollback) : 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일(취소)
    - 커밋과 롤백 > 무결성 보장
    - 트랜잭션 전파 : 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것
  
  - 일관성(consistency)
    
    - 허용된 방식으로만 데이터를 변경해야 하는 것
  
  - 격리성(isolation)
    
    - 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동
    - 격리성 SERIALIZABLE > REPEATABLE_READ > READ_COMMITTED > READ_UNCOMMITTED 동시성
    - REPEATABLE_READ : 팬텀 피드 발생
    - READ_COMMITTED : 팬텀 리드, 반복 가능하지 않은 조회 발생
    - READ_UNCOMMITTED : 팬텀 리드, 반복 가능하지 않은 조회, 더티 리드 발생
    - 팬텀 리드(phantom read) : 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우
    - 반복 가능하지 않은 조회(non-repeatable read) : 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우. 팬텀 리드와 차이점은 반복가능하지 않은 조회는 행 값이 달라질 수도 있는데, 팬텀 리드는 다른 행이 선택될 수도 있음
    - 더티 리드(dirty read) : 반복 가능하지 않는 조회와 유사하며 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 “커밋되지 않은” 행의 데이터를 읽을 수 있을 때 발생
    - SERIALIZABLE : 트랜잭션을 순차적으로 진행. 여러 트랜잭션이 동시에 같은 행에 접근할 수 없음. 교착 상태가 일어날 확률이 많고 가장 성능이 떨어지는 격리 수준
    - REPEATABLE_READ : 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 추가하는 것은 막지 않음 > 이후에 추가된 행이 발견될 수 있다.
    - READ_COMMITTED : 가장 많이 사용되는 격리 수준. 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없음. 즉, 커밋 완료된 데이터에 대해서만 조회 허용. 하지만 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있음
    - READ_UNCOMMITED : 가장 낮은 격리 수준. 하나의 트랜잭션이 커밋되지 이전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠름. 데이터 무결성을 위해 되도록이면 사용하지 않는 것이 이상적이나 몇몇 행이 제대로 조회되지 않더라도 괜찮은 거대한 양의 데이터를 어림잡아 집계하는 데에 적합
  
  - 지속성(durability)
    
    - 성공적으로 수행된 트랜잭션은 영원히 반영. 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함을 의미. 데이터 베이스는 체크썸, 저널링, 롤백 등의 기능 제공
    - 체크섬 : 중복 검사의 한 형태로 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법
    - 저널링 : 파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영(commit)하기 전에 로깅하는 것, 트랜잭션 등 변경 사항에 대한 로그를 남기는 것
  
  - 무결성
    
    - 데이터의 정확성, 일관성, 유효성을 유지하는 것
    - 개체 무결성 : 기본키로 선택된 필드는 빈 값을 허용하지 않는다.
    - 참조 무결성 : 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지
    - 고유 무결성 : 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값
    - NULL 무결성 : 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약 조건
  
  ## 데이터 베이스의 종류
  
  - 관계형 데이터 베이스 (RDBMS)
    - MySQL
    - PostgreSQL
  - NoSQL 데이터베이스
    - Not only SQL
    - SQL을 사용하지 않는 데이터베이스
    - mongoDB : json을 통해 데이터에 접근
    - redis : 인메모리 데이터베이스이자 키-값 데이터 모델 기반의 데이터베이스
  
  ## 인덱스
  
  - 인덱스의 필요성
    
    - 데이터를 빠르게 찾을 수 있는 하나의 장치
    - 인덱스를 설정하면 데이블 안에 내가 찾고자 하는 데이터를 빠르게 찾을 수 있음
  
  - B-트리
    
    - 인덱스는 보통 B-트리라는 자료구조
    - 루트 노드, 리프 노드, 루트 노드와 리프 노드 사이의 브랜치 노드
    - 인덱스가 효율적인 이유 : 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성
    - 대수확장성 : 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장. 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가.
  
  - 인덱스 만드는 방법
    
    - MySQL : 클러스터형 인덱스(primary key)와 세컨더리 인덱스(unique not null)
    - MongoDB : 도큐먼트를 만들면 자동으로 ObjectID가 형성, 해당 키가 기본 키. 세컨더리키도 부가적으로 설정해서 기본키와 세턴더리키를 같이 쓰는 복합 인덱스 설정 가능
  
  - 인덱스 최적화 기법
    
    - 인덱스는 비용이다.
      
      - 인덱스 리스트, 컬렉션 순으로 탐색하기 때문에 관련 읽기 비용 발생.
      
      - 컬렉션 수정 시 인덱스도 수정되어야 함
      
      - B-트리의 높이를 균형있게 조절하는 비용, 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용
      
      - 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 답이 아님
      
      - 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적
    
    - 항상 테스팅
      
      - 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다름 > 테스팅이 중요
      
      - explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간 최소화
    
    - 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순
      
      1. == 이나 equal이라는 쿼리가 있으면 제일 먼저 인덱스로
      
      2. 정렬에 쓰는 필드라면 그 다음 인덱스로
      
      3. 다중 값을 출력해야하는 필드, 즉 쿼리 자체가 > 이거나 < 등 많은 값을 출력해야하는 쿼리에 쓰는 필드라면 나중에 인덱스 설정
      
      4. 유니크한 값의 정도인 카디널리티의 순이 높은 순서를 기반으로 인덱스 설정





## 조인의 종류

- 조인 : 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것

- mongDB는 join에서 성능이 떨어지기 때문에 여러 테이블을 조인하는 작업이 많은 경우에는 MongoDB보다 다른 DB

- 내부 조인(inner join) : 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기

```sql
SELECT * FROM TableA A
INNER JOIN TableB B ON
A.key = B.key
```

- 왼쪽 조인(left outer join) : 왼쪽 테이블의 모든 행이 결과 테이블에 표기

```sql
SELECT * FROM TableA A
LEFT JOIN TableB B ON
A.key = B.key
```

- 오른쪽 조인(right outer join) : 오른쪽 테이블의 모든 행이 결과 테이블에 표기

```sql
SELECT * FROM TableA A
RIGHT JOIN TableB B ON
A.key = B.key
```

- 합집합 조인(full outer join) : 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기

```sql
SELECT * FROM TableA A
FULL OUTER JOIN TableB B ON
A.key = B.key
```





## 조인의 원리

- 중첩 루프 조인(NLJ, Nested Loop Join)
  
  - for문과 같은 원리로 조건에 맞는 조인을 하는 방법
  
  - 랜덤 접근에 대한 비용이 많이 증가하므로 대용량 테이블에서는 사용하지 않음
  
  - 블록 중첩 루프 조인(BNL, Block Nested Loop) : 조인할 테이블을 작은 블록으로 나눠서 블록 하나씩 조인하는 방식



- 정렬 병합 조인
  
  - 각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인
  
  - 조인할 때 쓸 적절한 인덱스가 없고 대용량의 테이블을 조인하며 조인 조건으로 범위 비교 연산자가 있을 때 사용

- 해시 조인
  
  - 해시 테이블 기반으로 조인하는 방법
  
  - 동등 조인에서만 사용 가능
  
  - 빌드 단계 : 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계
  
  - 프로브 단계 : 레코드 읽기 
  
  - 각 테이블을 한 번만 읽게 되어 중첩해서 두 개의 테이블을 읽는 중첩 루프 조인보다 보통 성능이 더 좋음
