## 4.3 트랜잭션과 무결성

### 4.3.1 트랜잭션

데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위

데이터베이스에 접근하는 방법은 쿼리, 즉 여러 개의 쿼리들을 하나로 묶는 단위

원자성, 일관성, 독립성, 지속성 = ACID 특징

<br />

#### 원자성

- 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징
  
  **커밋과 롤백**

- 커밋은 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어

- 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것

- 롤백은 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일(취소)

**트랜잭션 전파**

- 트랜잭션을 수행할 때 커넥션 단위로 수행하기 떄문에 커넥션 객체를 넘겨서 수행해야 함

- 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것을 트랜잭션 전파

<br />

#### 일관성

- 허용된 방식으로만 데이터를 변경해야 하는 것

- 데이터베이스에 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 함

<br />

#### 격리성

- 트랜잭션 수행 시 서로 끼어들지 못하는 것

- 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 함

- 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 함

- => 여러 개의 격리 수준으로 나뉘어 격리성을 보장

- 격리 수준
  
  - SERIALIZABLE, REPEATABLE_READ, READ_COMMITTED, READ_UNCOMMITTED
  
  - 위로 갈수록 동시성이 강해지지만 격리성은 약해짐
  
  - 아래로 갈수록 동시성은 약해지고 격리성은 강해짐
  
  - SERIALIZABLE은 격리성이 강한데 반해 동시성은 약함
  
  - REAPEATABLE_READ는 팬텀 리드
  
  - READ_COMMITTED는 팬텀리드, 반복가능하지 않은 조회 발생
  
  - READ_UNCOMMITTED는 팬텀 리드, 반복 가능하지 않은 조회, 더티 리드가 발생

<br />

##### 격리 수준에 따라 발생하는 현상

- 팬텀 리드
  
  - 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우

- 반복 가능하지 않은 조회
  
  - 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생, 그 값이 다른 경우
  
  - 팬텀 리드와 다른 점은 반복 가능하지 않은 조회는 행 값이 달라질 수도 있는데, 팬텀 리드는 다른 행이 선택될 수도 있다는 것을 의미

- 더티 리드
  
  - 반복 가능하지 않은 조회와 유사하며 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 행의 데이터를 읽을 수 있을 때 발생

##### 격리 수준

- SERIALIZABLE
  
  - 트랜잭션을 순차적으로 진행시키는 것을 말함
  
  - 여러 트랝개션이 동시에 같은 행에 접근할 수 없음
  
  - 이 수준은 매우 엄격한 수준으로 해당 행에 대해 격리시키고 이후 트랜잭션이 이 행에 대해 일어난다면 기다려야 함
  
  - 교착 상태가 일어날 확률도 많고 가장 성능이 떨어지는 격리 수준

- REPEATABLE_READ
  
  - 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 추가하는 것은 막지 않음
  
  - 이후에 추가된 행이 발견될 수도 있음

- READ_COMMITTED
  
  - 가장 많이 사용되는 격리 수준
  
  - MySQL8.0, PostgreSQL, SQL Server, 오라클
  
  - READ_UNCOMMITTED와는 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없음
  
  - 커밋 완료된 데이터에 대해서만 조회를 허용
  
  - 트랜잭션이 접근한 행을 다른 트랜잭션이 수정 가능

- READ_UNCOMMITTED
  
  - 가장 낮은 격리 수준
  
  - 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠름
  
  - 데이터 무결성을 위해 되도록이면 사용하지 않는 것이 이상적이나 몇몇 행이 제대로 조회되지 않더라도 괜찮은 거대한 양의 데이터를 어림잡아 집계하는 데 사용하면 좋음

<br />

#### 지속성

- 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것을 의미

- 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함

- 데이터베이스는 이를 위해 체크섬, 저널링, 롤백 등의 기능 제공
  
  - 체크섬: 중복 검사의 한 형태, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법
  
  - 저널링: 파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영하기 전에 로깅하는 것, 트랜잭션 등 변경 사항에 대한 로그를 남기는 것

<br />

### 4.3.2 무결성

데이터의 정확성, 일관성, 유효성을 유지하는 것

무결성이 유지되어야 데이터베이스에 저장된 데이터 값과 그 값에 해당하는 현실 세계의 실제 값이 일치하는지에 대한 신뢰가 생김

- 개체 무결성: 기본키로 선택된 필드는 빈 값을 허용하지 않음

- 참조 무결성: 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 함

- 고유 무결성: 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가짐

- NULL 무결성: 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약 조건

<br />

## 4.4 데이터베이스의 종류

### 4.4.1 관계형 데이터베이스

관계형 데이터베이스는 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스를 가리키며 SQL이라는 언어를 써서 조작

MySQL, PostgreSQL, 오라클, SQL Server, MSSQL

관계형 데이터베이스의 경우 표준 SQL은 지키기는 하지만 각각의 제품에 특화시킨 SQL을 사용

#### MySQL

대부분의 운영체제와 호환되며 현재 가장 많이 사용하는 데이터베이스

데이터베이스의 심장과도 같은 역할을 하는 곳이 바로 스토리지 엔진

모듈식 아키텍처로 쉽게 스토리지 엔진을 바꿀 수 있으며 뎅터 웨어하우징, 트랜잭션 처리, 고가용성처리에 강점을 두고 있음

스토리지 엔진 위에는 커넥터 API 및 서비스 계층을 통해 MySQL 데이터베이스와 쉽게 상호 작용 가능

MySQL은 쿼리 캐시를 지원해서 입력된 쿼리 문에 대한 전체 결과 집합을 저장하기 때문에 사용자가 작성한 쿼리가 캐시에 있는 쿼리와 동일하면 서버는 단순히 구문 분석, 최적화 및 실행을 건너뛰고 캐시의 출력만 표시

<br />

#### PostgreSQL

MySQL 다음으로 개발자들이 선호하는 데이터베이스 기술로 널리 인정받고 있음

디스크 조각이 차지하는 영역을 회수할 수 있는 장치인 VACUUM이 특징

<br />

### 4.4.2 NoSQL 데이터베이스

슬로건에서 생겨난 데이터베이스

SQL을 사용하지 않는 데이터베이스, MongoDB, redis

MongoDb는 JSON을 통해 데이터에 접근할 수 있음

Binary JSON 형태로 데이터가 저장되며 와이어드타이거 엔진이 기본 스토리지 엔진으로 장착된 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스

확장성이 뛰어나며 빅데이터를 저장할 때 성능이 좋고 고가용성과 샤딩, 레플리카셋을 지원

<br />

#### redis

인메모리 데이터베이스이자 키-값 데이터 모델 기반의 데이터베이스

기본적인 데이터 타입은 문자열이며 최대 512MB까지 저장가능

셋, 해시 등을 지원

pub/sub 기능을 통해 채팅 시스템, 다른 데이터베이스 앞단에 두어 사용하는 캐시 계층, 단순한 키-값이 필요한 세션 정보 관리, 정렬된 셋 자료 구조를 이용한 실시간 순위표 서비스에 사용

<br />

## 4.5 인덱스

### 4.5.1 인덱스의 필요성

인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치

<br />

### 4.5.2 B-트리

인덱스는 보통 B-트리라는 자료 구조로 이루어져 있음

루트 노드, 리프 노드, 브렌치 노드(루트 노드와 리프 노드 사이)

<br />

#### 인덱스가 효율적인 이유와 대수확장성

인덱스가 효율적인 이유는 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성

대수확장성이란 트리 깊이가 리프 노드 수에 비해 매우느리게 성장하는 것을 의미

기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가

<br />

### 4.5.3 인덱스 만드는 방법

#### MySQL

클러스터형 인덱스, 세컨더리 인덱스

클러스터형 인덱스는 테이블당 하나를 설정할 수 있음

primary key 옵션으로 기본키로 만들면 클러스터형 인덱스를 생성할 수 있고 기본키로 만들지 않고 unique not null 옵션을 붙이면 클러스터형 인덱스로 만들 수 있음

create index.. 명령어를 기반으로 세컨더리 인덱스를 만들 수 있음

하나의 인덱스만 생성할 것이라면 클러스터형 인덱스를 만드는 것이 세컨더리 인덱스를 만드는 것보다 성능이 좋음

세컨더리 인덱스는 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스

<br />

#### MongoDB

도큐먼트를 만들면 자동으로 ObjectID가 형성

해당 키가 기본키로 설정

세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수도 있음

<br />

### 4.5.4 인덱스 최적화 기법

데이터베이스마다 조금씩 다르지만 기본적인 골조는 똑같이 때문에 특정 데이터베이스를 기준으로 설명해도 무방

#### 1. 인덱스는 비용이다

먼저 인덱스는 두 번 탐색하도록 강요

인덱스 리스트, 그다음 컬렉션 순으로 탐색하기 때문이며 관련 읽기 비용이 들게 됨

컬렉션이 수정되었을 때 인덱스도 수정되어야 함

#### 2. 항상 테스팅 하라

인덱스 최적화 기법은 서비스 특징에 따라 달라짐

서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문

=> 항상 테스팅하는 것이 중요

explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화해야 함

#### 3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다

보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라짐

같음, 정렬, 다중 값, 카디널리티 순으로 생성해야 함

1. 어떠한 값과 같음을 비교하는 ==이나 equl이라는 쿼리가 있다면 제일 먼저 인덱스로 설정

2. 정렬에 쓰는 필드라면 그 다음 인덱스로 설정함

3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 >이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정

4. 유니크한 값의 정도를 카디널리티라고 함. 이 카디널리티가 높은 순서를   기반으로 인덱스를 생성해야 함

<br />

## 4.6 조인의 종류

조인이란 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것을 말함

MySQL에서는 JOIN이라는 쿼리로, MongoDB에서는 lookup이라는 쿼리로 이를 처리 가능

- 내부 조인(inner join): 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기

- 왼쪽 조인(left outer join): 왼쪽 테이블의 모든 행이 결과 테이블에 표기

- 오른쪽 조인(right outer join): 오른쪽 테이블의 모든 행이 결과 테이블에 표기

- 합집합 조인(full outer join): 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기

<br />

### 4.6.1 내부 조인

두 테이블 간에 교집합

<br />

### 4.6.2 왼쪽 조인

왼쪽 조인은 테이블 B의 일치하는 부분의 레코드와 함께 테이블 A를 기준으로 완전한 레코드 집합을 생성

만약 테이블 B에 일치하는 항목이 없으면 해당 값은 null 값이 됨

```
SELECT * FROM TableA A
LEFt JOIN TableB B ON
A.key = B.key
```

<br />

### 4.6.3 오른쪽 조인

오른쪽 조인은 테이블 A에서 일치하는 부분의 레코드와 함께 테이블 B를 기준으로 완전한 레코드 집합을 생성

만약 테이블 A에 일치하는 항목이 없으면 해당 값은 null 값이 됨

```
SELECT * FROM TableA A
RIGHT JOIN TableB B ON
A.key = B.key
```

<br />

### 4.6.4 합집합 조인

합집합 조인(완전 외부 조인)은 양쪽 테이블에서 일치하는 레코드와 함께 테이블A와 테이블 B의 모든 레코드 집합을 생성

일치하는 항목이 없으면 누락된 쪽에 null 값이 포함되어 출력

```
SELECT * FROM TableA A
FULL OUTER JOIN TableB B ON
A.key = B.key
```

<br />

## 4.7 조인의 원리

### 4.7.1 중첩 루프 조인

중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법

랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사용하지 않음

중첩 루프 조인에서 발전한 조인할 테이블을 작은 블록으로 나눠서 블록 하나씩 조인하는 블록 중첩 루프 조인이라는 방식도 있음

<br />

### 4.7.2 정렬 병합 조인

각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인

조인할 때 쓸 적절한 인덱스가 없고 대용량의 테이블들을 조인하고 조인 조건으로 <, > 등 범위 비교 연산자가 있을 때 씀

<br />

### 4.7.3 해시 조인

해시 테이블을 기반으로 조인하는 방법

 두 개의 테이블을 조인한다고 했을 때 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적

동등 조인에서만 사용 가능

- 빌드 단계
  
  - 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계

- 프로브 단계
  
  - 레코드 읽기를 시작하며, 각 레코드에서 persons.country_id에 일치하는 레코드를 찾아서 결괏값으로 반환
