#### 트랜잭션과 무결성

#### 트랜잭션

- 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위. 여러 개의 쿼리들을 하나로 묶는 단위
- 원자성(atomicity): 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징
- 일관성(consistency): ‘허용된 방식’으로만 데이터를 변경해야 하는 것. 데이터베이스에 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 함
- 독립성(isolation): 트랜잭션 수행 시 서로 끼어들지 못하는 것. 복수의 병렬 트랜잭션은 서로 격리 되어 마치 순차적으로 실행되는 것처럼 작동되어야 하고, 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 함
  - 격리 수준: 
    - SERIALIZABLE: 강한 격리성, 약한 동시성. 트랜잭션을 순차적으로 진행시키는 것
    - REPEATABLE_READ
    - READ_COMMITTED: 가장 많이 사용되는 격리 수준
      - 커밋 완료된 데이터에 대해서만 조회를 허용: READ_UNCOMMITTED와는 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없음
    - READ_UNCOMMITTED: 약한 동시성, 강한 격리성
      - 가장 낮은 격리 수준으로, 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노 출되는 문제가 있지만 가장 빠름
  - 격리 수준에 따라 발생하는 현상
    - 팬텀 리드: 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우
    - 반복 가능하지 않은 조회:  트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우
      - 반복 가능하지 않은 조회는 행 값이 달라질 수도 있는데, 팬텀 리드는 다른 행이 선택될 수도 있음
    - 더티 리드: 반복 가능하지 않은 조회와 유사하며 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 ‘커밋되지 않은’ 행의 데이터를 읽을 수 있을 때 발생
- 지속성(durability): 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것
  - 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함
  - 데이터베이스에서 체크섬(중복 검사), 저널링(변경사항 로깅), 롤백 기능 제공

#### 무결성

- 데이터의 정확성, 일관성, 유효성을 유지하는 것
- 무결성이 유지되어야 데이터베이스 저장된 데이터값, 실제값이 일치하는지에 대한 신뢰가 생김
- 무결성의 종류
  - 개체 무결성: 기본키로 선택된 필드는 빈 값을 허용하지 않음
  - 참조 무결성: 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 함
  - 고유 무결성: 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가짐
  - NULL 무결성: 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약 조건

## 4.4 데이터베이스의 종류

#### 관계형 데이터베이스

행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스

- MySQL: 대부분의 운영체제와 호환되며 현재 가장 많이 사용하는 데이터베이스
  - C, C++로 만들어짐 
  - MyISAM 인덱스 압축 기술, B-트리 기반의 인덱스, 스레드 기반의 메모리 할당 시스템, 매우 빠른 조인, 최대 64개의 인덱스를 제공
  - 대용량 데이터베이스를 위해 설계되어 있음
  - 롤백, 커밋, 이중 암호지원 보안 등 기능 제공
- PostgreSQL: MySQL 다음으로 개발자들이 선호하는 데이터베이스 기술
  - VACUUM: 디스크 조각이 차지하는 영역을 회수할 수 있는 장치
  - 최대 테이블 크기: 32TB,
  - JSON을 이용해서 데이터에 접근 가능
  - 지정시간에 복구하는 기능, 로깅, 접근 제어, 중첩된 트랜잭션, 백업 등 가능



#### NoSQL 데이터베이스

- SQL을 사용하지 않는 데이터베이스
- MongoDB
  - SON을 통해 데이터에 접근 가능
  - Binary JSON 형태로 데이터 저장
  - 이어 드타이거 엔진이 기본 스토리지 엔진으로 장착된 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스
  - 확장성이 뛰어나며 빅데이터를 저장할 때 성능이 좋고 고가용성과 샤딩, 레플리카셋을 지원
  - 스키마를 정해 놓지 않고 데이터를 삽입할 수 있기 때문에 다양한 도메인의 데이터베이스를 기반으로 분석하거 나 로깅 등을 구현할 때 강점
  - 도큐먼트를 생성할 때마다 다른 컬렉션에서 중복된 값을 지니기 힘든 유니크한 값인 Object ID가 생성됨
    - 기본키로 유닉스 시간 기반의 타임스탬프(4바이트), 랜덤 값(5바이트), 카운터(3바이트)로 이루어져 있음
- redis
  - 인메모리 데이터베이스이자 키-값 데이터 모델 기반의 데이터베이스
  - 기본적인 데이터 타입은 문자열(string)
  - 최대 512MB까지 저장 가능
  - 셋, 해시 등 지원
  - pub/sub 기능을 통해 채팅 시스템, 다른 데이터베이스 앞단에 두어 사용하는 캐싱 계층, 단순한 키-값이 필요한 세션 정보 관리, 정렬된 셋(sorted set) 자료 구조를 이용한 실시간 순위표 서비스에 사용



### 4.5 인덱스

#### 인덱스의 필요성

- 데이터를 빠르게 찾을 수 있는 하나의 장치



#### B-트리

- 루트 노드, 리프 노드, 브랜치 노드

- 인덱스가 효율적인 이유
  - 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수 확장성 때문
  - 대수확장성: 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것
  - 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가함

#### 인덱스를 만드는 방법

- MySQL
  - 클러스터형 인덱스
    - 테이블당 하나 설정 가능
  - 세컨더리 인덱스
    - 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스
  - 하나의 인덱스만 생성할 것 이라면 클러스터형 인덱스를 만드는 것이 세컨더리 인덱스를 만드는 것보다 성능이 좋음
- MongoDB
  - 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정됨
  - 기본키와 세컨더리키 같이 쓰는 복합 인덱스 설정 가능



#### 인덱스 최적화 기법



### 조인의 종류

- 내부 조인(inner join): 교집합. 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기
- 왼쪽 조인(left outer join): 왼쪽 테이블의 모든 행이 결과 테이블에 표기
- 오른쪽 조인(right outer join): 오른쪽 테이블의 모든 행이 결과 테이블에 표기
- 합집합 조인(full outer join): 완전 외부 조인. 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기



### 조인의 원리

#### 중첩 루프 조인(NLJ, Nested Loop Join)

- 중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법
- 랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사용하지 않음



#### 정렬 병합 조인

- 각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인
- 조인할 때 쓸 적절한 인덱스가 없고
- 대용량의 테이블들을 조인하고
- 조인 조건으로 <. > 등 범위 비교 연산자가 있을 때 씀



#### 해시 조인

- 해시 테이블을 기반으로 조인하는 방법
- 두 개의 테이블 조인 시, 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적
- 동등 조인에서만 사용 가능
- 빌드 단계
  - 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계
  - 조인에 사용되는 필드가 해시 테이블의 키로 사용됨
- 프로브 단계
  - 프로브 단계 동안 레코드 읽기 시작
  - 각 테이블은 한 번씩만 읽게 되어 중첩해서 두 개의 테이블을 읽는 중첩 루프 조인보다 보통은 성능이 더 좋음

