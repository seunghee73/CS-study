## 3. 운영체제

> 운영체제(OS, Operating System): 사용자가 컴퓨터를 쉽게 다루게 해주는 인터페이스

### 3.1 운영체제와 컴퓨터

#### 3.1.1 운영체제의 역할과 구조

- 운영체제의 역할

  1. CPU 스케줄링과 프로세스 관리: CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반 환을 관리

  2. 메모리 관리: 한정된 메모리를 어떤 프로세스에 얼마큼 할당해야 하는지 관리
  3. 디스크 파일 관리: 디스크 파일을 어떠한 방법으로 보관할지 관리
  4. I/O 디바이스 관리: I/O 디바이스들인 마우스, 키보드와 컴퓨터 간에 데이터를 주고받는 것을 관리

- 운영체제의 구조

  - 유저 프로그램(Top) - 운영체제 [ GUI - 시스템콜 - 커널 - 드라이버 ] - 하드웨어(Bottom)
  - 시스템콜: 운영체제가 커널에 접근하기 위한 인터페이스, 커널 함수 호출 시 사용. 유저모드가 아닌 커널모드에서 파일을 읽는 과정을 통해 직접 접근을 차단하고, 프로그램을 다른 프로그램에서 보호 가능
    - modebit: 1(유저모드) 또는 0(커널모드)의 값을 가지는 플래그 변수. I/O 디바이스를 운영체제를 통해 작동하게 하여 사용자 의도에 맞춰 로직 실행

#### 3.1.2 컴퓨너의 요소

- CPU: 산술논리연산장치, 제어장치, 레지스터로 구성되어 있는 컴퓨터 장치. 인터럽트에 의해 단순히 메모리에 존재하는 명령어를 해석해서 실행
  - 인터럽트: 어떤 신호가 들어왔을 때 CPU를 잠시 정지시키는 것. 인터럽트 간 우선순위에 따라 실행됨
    - 하드웨어 인터럽트: 키보드를 연결한다거나 마우스를 연결하는 일 등의 IO 디바이스에서 발생하는 인터럽트
    - 소프트웨어 인터럽트: 트랩(trap)이라고도 함. 프로세스 오류 등으로 프로세스가 시스템콜을 호출할 때 발동
- DMA 컨트롤러: I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치. CPU의 부하를 막아주는 보조장치
- 메모리: 전자회로에서 데이터나 상태, 명령어 등을 기록하는 장치
- 타이머: 몇 초 안에는 작업이 끝나야 한다는 것을 정하고 특정 프로그램에 시간 제한을 다는 역할
- 디바이스 컨트롤러: 컴퓨터와 연결되어 있는 IO 디바이스들의 작은 CPU

---

### 3.2 메모리

#### 3.2.1 메모리 계층

- 메모리 계층 구조

  - 레지스터: CPU 안에 있는 작은 메모리, 휘발성, 속도 가장 빠름, 기억용량이 가장 적음

  - 캐시: L1, L2 캐시. 휘발성, 속도 빠름, 기억 용량이 적음.

  - 주기억장치: RAM. 휘발성, 속도 보통, 기억 용량 보통

  - 보조기억장치: HDD, SDD. 휘발성, 속도 낮음, 기억 용량이 많음

- 캐시: 데이터를 미리 복사해 놓는 임시 저장소. 빠른 장치와 느린 장치에서 속도 차이에 따른 **병목 현상**을 줄이기 위한 메모리
  - 지역성의 원리: 캐시 계층을 두는 것이 아니라 캐시를 직접 설정할 때 자주 사용하는 데이터를 기반으로 설정해야 함. 지역성은 자주 사용하는 데이터에 대한 근거
    - 시간 지역성(temporal locality): 최근 사용한 데이터에 다시 접근하려는 특성
    - 공간 지역성(spatial locality): 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성
- 캐시히트와 캐시미스
  - 캐시히트: 캐시에서 원하는 데이터를 찾음
    - 해당 데이터를 제어장치를 거쳐 가져오게 되어 위치도 가깝고 CPU 내부 버스 기반으로 작동하므로 빠름
  - 캐시미스: 해당 데이터에 캐시가 없어서 주 메모리로 가서 데이터를 찾아옴
    - 메모리에서 가져오게 되는데, 시스템 버스를 기반으로 작동하여 느림
  - 캐시매핑: 캐시가 히트되기 위해 매핑하는 방법
    - 직접 매핑: 메모리가 1~100이 있고 캐시가 1~10이 있다면 1:1~10, 2:1~20... 이런 식으로 매핑하는 것 처리가 빠르지만 충돌 발생이 잦음.
    - 연관 매핑: 순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑. 충돌이 적으나 모든 블록을 탐색해야 해서 속도가 느림
    - 집합 연관 매핑: 직접 매핑+연관 매핑. 순서는 일치시키지만 집합을 둬서 저장하며 블록화되어있기 때문에 검색은 좀 더 효율적

#### 3.2.2 메모리 관리

- 가상 메모리: 메모리 관리 기법. 컴퓨터가 실제 이용 가능한 메모리 자원을 추상화하여 사용자에게 매우 큰 메모리로 보이게 만드는 것
  - 스와핑: 페이지폴트를 방지하도록 당장 사용하지 않는 영역을 하드디스크로 옮겨 필요할 때 다시 RAM으로 불러와 올리고, 사용하지 않으면 다시 하드디스크로 내림을 반복하여 RAM을 효과적으로 관리하는 것
  - 페이지 폴트: 프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우 발생
- 스레싱: 메모리의 페이지 폴트율이 높은 것. 컴퓨터의 심각한 성능 저하를 초래함
  - 작업 세트: 프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어 미리 메모리에 로드하는 것. 이를 통해 탐색 비용을 줄이고 스와핑도 줄일 수 있음
  - PFF: 페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만들어, 상한선에 도달하면 페이지를 늘리고 하한선에 도달하면 페이지를 줄임
- 메모리 할당
  - 연속 할당: 메모리에 연속적으로 공간을 할당
    - 고정 분할 방식: 메모리를 미리 나누어 관리. 메모리가 미리 나뉘어 있어서 융통성이 없음. 내부 단편화 발생
    - 가변 분할 방식: 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용. 내부 단편화는 발생하지 않고 외부 단편화는 발생할 수 있음. 
      - 최초적합: 위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당
      - 최적적합: 프로세스 크기 이상인 공간 중 가장 작은 홀부터 할당
      - 최악적합: 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당
    - 내부 단편화: 메모리를 나눈 크기보다 **프로그램이 작아서** 들어가지 못하는 공간이 많이 발생하는 현상
    - 외부 단편화: 메모리를 나눈 크기보다 **프로그램이 커서** 들어가지 못하는 공간이 많이 발생하는 현상
  - 불연속 할당: 메모리를 연속적으로 할당하지 않음
    - 페이징 기법: 메모리를 동일한 크기의 페이지 단위로 나누어 서로 다른 위치에 프로세스 할당. 홀의 크기가 균일하지 않은 문제가 없어짐. 주소 변환이 복잡
    - 세그멘테이션: 의미 단위인 세그먼트 단위로 나누는 방식
    - 페이지드 세그멘테이션: 공유나 보안을 의미 단위의 세그먼트로 나누고, 물리적 메모리는 페이지로 나누는 것

- 페이지 교체 알고리즘

  메모리는 한정되어 있기 때문에 스와핑이 많이 일어나는데, 많이 일어나지 안ㄷ호록 설계되어야 함. 이는 페이지 교체 알고리즘을 기반으로 스와핑 발생

  - 오프라인 알고리즘: 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘이며 가장 좋은 방법. 그러나 사용할 수 없는 알고리즘이고, 다른 알고리즘과의 성능 비교에 대한 기준 제공
  - FIFO: 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법
  - LRU: 참조가 가장 오래된 페이지를 바꿈
  - NUR: LRU에서 발전. 일명 clock 알고리즘. 시계 방향으로 돌면서 0(참조되지 않음)을 찾고 0을 찾은 순간 해당 프로세스 교체, 해당 부분을 1(최근에 참조됨)으로 바꿈
  - LFU: 가장 참조 횟수가 적은 페이지를 교체. 많이 사용되지 않은 것 교체