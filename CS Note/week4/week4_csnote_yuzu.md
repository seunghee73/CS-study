| week4 | Chapter 3|
| ---------- | ------------ |
<br>

# 3. 운영체제

<br>

## 3.1 운영체제와 컴퓨터
### 3.1.1 운영체제의 역할과 구조
#### * 운영체제의 역할
- CPU 스케줄링과 프로세스 관리
- 메모리 관리
- 디스크 파일 관리
- I/O 디바이스 관리
#### * 운영체제의 구조
- (유저프로그램), GUI, 시스템콜, 커널, 드라이버, (하드웨어)
- 시스템콜
	- 커널에 접근하기 위한 인터페이스
	- 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 사용
	- 유저 프로그램이 I/O 요청으로 트랩을 발동하면 올바른 I/O 요청인지 확인한 후 유저 모드가 시스템콜을 통해 커널 모드로 변환되어 실행됨
		- 컴퓨터 자원에 대한 직접 접근을 차단할 수 있고 프로그램을 다른 프로그램으로부터 보호할 수 있음
	- modebit
		- 시스템콜이 작동될 때 모드빗을 참고해서 유저모드와 커널모드를 구분
		- 1 또는 0
### 3.1.2 컴퓨터의 요소
#### * CPU
- 산술논리연산장치, 제어장치, 레지스터로 구성되어 있는 컴퓨터 장치
- 인터럽트에 의해 단순히 메모리에 존재하는 명령어를 해석해서 실행
- 제어장치: 프로세스 조작을 지시하는 CPU의 한 부품
- 레지스터: CPU 안에 있는 매우 빠른 임시기억장치
- 산술논리연산장치: 산술 연산과 배타적 논리합, 논리곱 같은 논리 연산을 계산하는 디지털 회로
- 연산처리
	- 제어장치가 메모리에 계산할 값을 로드함. 레지스터에도 로드함
	- 제어장치가 레지스터에 있는 값을 계산하라고 산술논리연산장치에 명령함
	- 제어장치가 계산된 값을 다시 레지스터에서 메모리로 계산한 값을 저장함
- 인터럽트: 어떤 신호가 들어왔을 때 CPU를 잠깐 정지시키는 것
	- 하드웨어 인터럽트: IO 디바이스에서 발생하는 인터럽트
	- 소프트웨어 인터럽트: (트랩) 프로세스 오류 등으로 프로세스가 시스템콜을 호출할 때 발동
#### * DMA 컨트롤러
- I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하뒈어 장치
- CPU의 부하를 막아줌
#### * 메모리
- 전자회로에서 데이터나 상태, 명령어 등을 기록하는 장치
#### * 타이머
- 특정 프로그램에 시간 제한을 다는 역할
- 시간이 많이 걸리는 프로그램이 작동할 때 제한을 걸기 위해 존재
#### * 디바이스 컨트롤러
- 컴퓨터와 연결되어 있는 IO 디바이스들의 작은 CPU

<br>

## 3.2 메모리
### 3.2.1 메모리 계층
- 레지스터: CPU안에 있는 작은 메모리, 휘발성, 속도 가장 빠름, 기억용량 가장 적음
- 캐시: L1, L2 캐시를 지칭, 휘발성, 속도 빠름, 기억 용량이 적음
- 주기억장치: RAM, 휘발성, 속도 보통, 기억 용량 보통
- 보조기억장치: HDD, SDD, 휘발성, 속도 낮음, 기억 용량 많음
#### * 캐시
- 데이터를 미리 복사해 놓는 임시 저장소
- 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리
### 3.2.2 메모리 관리
#### * 가상 메모리
- 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 매우 큰 메모리로 보이게 만드는 것
- TLB: 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시, 가상 메모리에서 속도 향상을 위해 사용
- 스와핑: 당장 사용하지 않는 영역을 하드디스크로 옮겨 필요할 때 다시 RAM으로 불러와 올리고, 사용하지 않으면 다시 하드디스크로 내림을 반복하여 RAM을 효과적으로 관리하는 것
- 페이지 폴트: 프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우 발생
- 페이지 폴트와 그로 인한 스와핑
	- CPU는 물리 메모리를 확인하여 해당 페이지가 없으면 트랩을 발생해 운영체제에 알림
	- 운영체제는 CPU의 동작을 잠시 멈춤
	- 운영체제는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인하고 없으면 프로세스를 중단하고 현재 물리 메모리에 비어 있는 프레임이 있는지 찾음, 물리 메모리에도 없다면 스와핑이 발동
	- 비어 있는 프레임에 해당 페이지를 로드하고 페이지 테이블을 최신화 함
	- 중단되었던 CPU를 다시 시작
#### * 스레싱
- 메모리의 페이지 폴트율이 높은 것을 의미
- 해결 방법
	- 작업세트: 프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드
	- PFF: 페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만드는 방법
#### * 메모리 할당
- 연속 할당: 메모리에 연속적으로 공간을 할당
	- 고정 분할 방식: 메모리를 미리 나누어 관리, 융통성 없음, 내부 단편화 발생
	- 가변 분할 방식: 매 시점 크기에 맞게 동적으로 메모리를 나눠 사용, 외부 단편화 발생할 수 있음
		- 최초적합: 위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당
		- 최적적합: 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당
		- 최악적합: 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당
- 불연속 할당: 메모리를 연속적으로 할당하지 않음
	- 페이징: 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당, 홀의 크기가 균일하지 않은 문제가 없어지지만 주소 변환이 복잡해짐
	- 세그멘테이션: 세그먼트 단위로 나누는 방식, 공유와 보안 측면에서 좋으나 홀 크기가 균일하지 않음
	- 페이지드 세그멘테이션: 공유나 보안은 세그먼트로 나누고 물리적 메모리는 페이지로 나눔
#### * 페이지 교체 알고리즘
- 오프라인 알고리즘: 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘, 미래를 예측할 수 없으므로 사용할 수 없는 알고리즘이지만 성능 비교에 대한 기준을 제공
- FIFO: 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법
- LRU: 참조가 가장 오래된 페이지를 바꿈, 오래된 것을 파악하기 위해 계수기, 스택을 두어야 한다는 문제점이 있음
- NUR: clock 알고리즘, 0을 찾으면 해당 프로세스를 교체하고 해당 부분을 1로 바꿈
- LFU: 가장 참조 횟수가 적은 페이지를 교체

<br>
